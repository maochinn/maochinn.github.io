---
title: "【Blender】客製化建立Texture"
author: "帽捲"
date: 2024-07-26T01:54:56.455+0000
last_modified_at: 2024-07-26T01:54:56.455+0000
categories: ["Maochinn"]
tags: ["blender"]
description: "本篇簡單介紹如何透過Blender建立Texture並輸出，純粹只是解決一個很簡單的問題，怎麼快速的利用數值陣列去建立貼圖或者修改某個像素的值，事實上，要做到這件事情可以裝個Python和一些插件也做得到，但為什麼這麼要介紹利用Blender呢？因為Blender有還不錯的介面，…"
image:
  path: /assets/8b414b22f7fb/1*sfowxbeuPPPNWcDNPhl8KQ.png
render_with_liquid: false
---

### 【Blender】客製化建立Texture

本篇簡單介紹如何透過Blender建立Texture並輸出，純粹只是解決一個很簡單的問題，怎麼快速的利用數值陣列去建立貼圖或者修改某個像素的值，事實上，要做到這件事情可以裝個Python和一些插件也做得到，但為什麼這麼要介紹利用Blender呢？因為Blender有還不錯的介面，可以查看個別像素的數值，同時，輸出的常見格式也有支援，另外，基本也不用再另外安裝其他東西，當然仍有擴充的彈性。

首先，這邊就做一個非常簡單的舉例，生成一張21\*9的圖片，其中每個像素就是UV值，值的範圍固定在0\.0~1\.0之間，我們不妨借用 [【Blender】客製化生成簡單Mesh](https://medium.com/maochinn/blender-%E5%AE%A2%E8%A3%BD%E5%8C%96%E7%94%9F%E6%88%90%E7%B0%A1%E5%96%AEmesh-7d0a224d5400?source=your_stories_page-------------------------------------){:target="_blank"} 的腳本來修改成以下，並執行。
```python
import bpy
import mathutils

list = []
list.append((0.0000,    0.0000))
list.append((45.0000, 0.0000))
list.append((90.0000,   0.0000))
list.append((135.0000, 0.0000))
list.append((180.0000, 0.0000))
list.append((225.0000, 0.0000))
list.append((270.0000, 0.0000))
list.append((315.0000, 0.0000))
list.append((360.0000, 0.0000))
list.append((405.0000, 0.0000))
list.append((450.0000, 0.0000))
list.append((495.0000, 0.0000))
list.append((540.0000, 0.0000))
list.append((585.0000, 0.0000))
list.append((630.0000, 0.0000))
list.append((675.0000, 0.0000))
list.append((720.0000, 0.0000))
list.append((765.0000, 0.0000))
list.append((810.0000, 0.0000))
list.append((855.0000, 0.0000))
list.append((900.0000, 0.0000))
list.append((0.0000,    50.0000))
list.append((45.0000,   50.0000))
list.append((90.0000,   50.0000))
list.append((135.0000, 50.0000))
list.append((180.0000, 50.0000))
list.append((225.0000, 50.0000))
list.append((270.0000, 50.0000))
list.append((315.0000, 50.0000))
list.append((360.0000, 50.0000))
list.append((405.0000, 50.0000))
list.append((450.0000, 50.0000))
list.append((495.0000, 50.0000))
list.append((540.0000, 50.0000))
list.append((585.0000, 50.0000))
list.append((630.0000, 50.0000))
list.append((675.0000, 50.0000))
list.append((720.0000, 50.0000))
list.append((765.0000, 50.0000))
list.append((810.0000, 50.0000))
list.append((855.0000, 50.0000))
list.append((900.0000, 50.0000))
list.append((0.0000,    100.0000))
list.append((45.0000,   100.0000))
list.append((90.0000,   100.0000))
list.append((135.0000, 100.0000))
list.append((180.0000, 100.0000))
list.append((225.0000, 100.0000))
list.append((270.0000, 100.0000))
list.append((315.0000, 100.0000))
list.append((360.0000, 100.0000))
list.append((405.0000, 100.0000))
list.append((450.0000, 100.0000))
list.append((495.0000, 100.0000))
list.append((540.0000, 100.0000))
list.append((585.0000, 100.0000))
list.append((630.0000, 100.0000))
list.append((675.0000, 100.0000))
list.append((720.0000, 100.0000))
list.append((765.0000, 100.0000))
list.append((810.0000, 100.0000))
list.append((855.0000, 100.0000))
list.append((900.0000, 100.0000))
list.append((0.0000,    150.0000))
list.append((45.0000,   150.0000))
list.append((90.0000,   150.0000))
list.append((135.0000, 150.0000))
list.append((180.0000, 150.0000))
list.append((225.0000, 150.0000))
list.append((270.0000, 150.0000))
list.append((315.0000, 150.0000))
list.append((360.0000, 150.0000))
list.append((405.0000, 150.0000))
list.append((450.0000, 150.0000))
list.append((495.0000, 150.0000))
list.append((540.0000, 150.0000))
list.append((585.0000, 150.0000))
list.append((630.0000, 150.0000))
list.append((675.0000, 150.0000))
list.append((720.0000, 150.0000))
list.append((765.0000, 150.0000))
list.append((810.0000, 150.0000))
list.append((855.0000, 150.0000))
list.append((900.0000, 150.0000))
list.append((0.0000,    200.0000))
list.append((45.0000,   200.0000))
list.append((90.0000,   200.0000))
list.append((135.0000, 200.0000))
list.append((180.0000, 200.0000))
list.append((225.0000, 200.0000))
list.append((270.0000, 200.0000))
list.append((315.0000, 200.0000))
list.append((360.0000, 200.0000))
list.append((405.0000, 200.0000))
list.append((450.0000, 200.0000))
list.append((495.0000, 200.0000))
list.append((540.0000, 200.0000))
list.append((585.0000, 200.0000))
list.append((630.0000, 200.0000))
list.append((675.0000, 200.0000))
list.append((720.0000, 200.0000))
list.append((765.0000, 200.0000))
list.append((810.0000, 200.0000))
list.append((855.0000, 200.0000))
list.append((900.0000, 200.0000))
list.append((0.0000,    250.0000))
list.append((45.0000,   250.0000))
list.append((90.0000,   250.0000))
list.append((135.0000, 250.0000))
list.append((180.0000, 250.0000))
list.append((225.0000, 250.0000))
list.append((270.0000, 250.0000))
list.append((315.0000, 250.0000))
list.append((360.0000, 250.0000))
list.append((405.0000, 250.0000))
list.append((450.0000, 250.0000))
list.append((495.0000, 250.0000))
list.append((540.0000, 250.0000))
list.append((585.0000, 250.0000))
list.append((630.0000, 250.0000))
list.append((675.0000, 250.0000))
list.append((720.0000, 250.0000))
list.append((765.0000, 250.0000))
list.append((810.0000, 250.0000))
list.append((855.0000, 250.0000))
list.append((900.0000, 250.0000))
list.append((0.0000,    300.0000))
list.append((45.0000,   300.0000))
list.append((90.0000,   300.0000))
list.append((135.0000, 300.0000))
list.append((180.0000, 300.0000))
list.append((225.0000, 300.0000))
list.append((270.0000, 300.0000))
list.append((315.0000, 300.0000))
list.append((360.0000, 300.0000))
list.append((405.0000, 300.0000))
list.append((450.0000, 300.0000))
list.append((495.0000, 300.0000))
list.append((540.0000, 300.0000))
list.append((585.0000, 300.0000))
list.append((630.0000, 300.0000))
list.append((675.0000, 300.0000))
list.append((720.0000, 300.0000))
list.append((765.0000, 300.0000))
list.append((810.0000, 300.0000))
list.append((855.0000, 300.0000))
list.append((900.0000, 300.0000))
list.append((0.0000,    350.0000))
list.append((45.0000,   350.0000))
list.append((90.0000,   350.0000))
list.append((135.0000, 350.0000))
list.append((180.0000, 350.0000))
list.append((225.0000, 350.0000))
list.append((270.0000, 350.0000))
list.append((315.0000, 350.0000))
list.append((360.0000, 350.0000))
list.append((405.0000, 350.0000))
list.append((450.0000, 350.0000))
list.append((495.0000, 350.0000))
list.append((540.0000, 350.0000))
list.append((585.0000, 350.0000))
list.append((630.0000, 350.0000))
list.append((675.0000, 350.0000))
list.append((720.0000, 350.0000))
list.append((765.0000, 350.0000))
list.append((810.0000, 350.0000))
list.append((855.0000, 350.0000))
list.append((900.0000,  350.0000))
list.append((0.0000,    400.0000))
list.append((45.0000,   400.0000))
list.append((90.0000,   400.0000))
list.append((135.0000, 400.0000))
list.append((180.0000, 400.0000))
list.append((225.0000, 400.0000))
list.append((270.0000, 400.0000))
list.append((315.0000, 400.0000))
list.append((360.0000, 400.0000))
list.append((405.0000, 400.0000))
list.append((450.0000, 400.0000))
list.append((495.0000, 400.0000))
list.append((540.0000, 400.0000))
list.append((585.0000, 400.0000))
list.append((630.0000, 400.0000))
list.append((675.0000, 400.0000))
list.append((720.0000, 400.0000))
list.append((765.0000, 400.0000))
list.append((810.0000, 400.0000))
list.append((855.0000, 400.0000))
list.append((900.0000, 400.0000))

# Modify Displacement Map (Be Generated by bpy.ops.image.new())
################################### 
bpy.ops.image.new(name='LDR', width=21, height=9)
map = bpy.data.images['LDR'];
w = map.size[0]
h = map.size[1]

for y in range(h):
    for x in range(w):
        idx = y * w + x
        for i in range(4):
            map.pixels[idx*4+0] = list[idx][0] / 900.0
            map.pixels[idx*4+1] = list[idx][1] / 400.0
            map.pixels[idx*4+2] = 0.0
            map.pixels[idx*4+3] = 1.0
            
map.update()
```

簡單來說就是生成一張名為 _LDR_ 的map，稍微有點麻煩的是Blender中的圖片是用float一維陣列去儲存，且每個pixel有4個通道，因此，座標\(X,Y\)=\(0, 0\)對應的RGBA是pixels\[0\]、pixels\[1\]、pixels\[2\]、pixels\[3\]，座標\(X,Y\)=\(1,0\)=對應的RGBA是pixels\[4\]、pixels\[5\]、pixels\[6\]、pixels\[7\]，以此類推。其中，我把\(0~400, 0~900\)的值除以\(400, 900\)當作RG channels的值，依序塞給每個pixel，簡單來說就是由左向右，由下到上的填0~1的值給每個pixel。

接著打開Rendering的Layout，並且選取New左邊的list，找到LDR圖片。


![](/assets/8b414b22f7fb/1*Zgc9ZNL_bdbhIKIO1iSubg.png)


打開之後，應該就可以看到一個低解析度的UV貼圖，可以打開右邊的Image看一些資訊，首先，這是一個21\*9的圖片，Color Space是 **sRGB** 。


![](/assets/8b414b22f7fb/1*funeiy1cpYvVmiiwS-g85g.png)



![圖1\.1 LDR\(Linear\)](/assets/8b414b22f7fb/1*OgrYvkGaJQ4vgVXuv8YCPw.png)

圖1\.1 LDR\(Linear\)

接著我們可以用右鍵點擊某個點就會在右下角顯示對應的座標、RGB、HSV等資訊，但是可以注意到，座標\(1, 0\)對應的值根據腳本理論上應該為
```python
(45.0000, 0.0000) / (900, 400) = (0.05, 0)
```

但是實際上點擊發現R=0\.059，與理論值有些為落差，主要是因為通常圖片每個pixel使用24bit來儲存，其中每個channel使用8bit來儲存，雖然在腳本中看到的pixels是用float儲存，但是實際上拿去GPU rendering時是用unsigned char儲存。

換言之，儲存的範圍是0~255，如果normalize到0~1的話就是切成256階，舉例來說，從小到大每一階是0/255、1/255、2/255\. \. \.以此類推，因此，沒有辦法準確儲存0\.5這個值，只能儲存最接近的值13/255 = 0\.05098039215。


![圖1\.2 LDR\[0\] \[1\]](/assets/8b414b22f7fb/1*MncuNC4GNDvP-_dwHCPw7Q.png)

圖1\.2 LDR\[0\] \[1\]

如果想要儲存更準確的值，那就勢必要使用更多bit去儲存，因此可以把腳本部分修改成
```python
bpy.ops.image.new(name='HDR', width=21, height=9, float=True)
map = bpy.data.images['HDR'];
```

簡單來說就是多加一個參數 _float=True_ ，也就是讓每個channel使用float儲存，也就是32bit，基本上，你可以當作可以準確儲存任何數字了，甚至值域也不只限於0\.0~1\.0。於是我們一樣回到Rendering的Layout查看。


![](/assets/8b414b22f7fb/1*sfowxbeuPPPNWcDNPhl8KQ.png)



![圖2\.1 HDR\(Linear\)](/assets/8b414b22f7fb/1*i7Nvrhw1tIn5xKeeMfwDTg.png)

圖2\.1 HDR\(Linear\)

基本上點擊相同位置你可以看到更準確的值。


![圖2\.2 HDR\[0\] \[1\] \(Linear\)](/assets/8b414b22f7fb/1*1bj-19oNAK_g8iwmbl6X8w.png)

圖2\.2 HDR\[0\] \[1\] \(Linear\)

事實上，使用float儲存貼圖，一個常見的應用就是所謂的HDR \(High Dynamic Range Imaging\)，相對來說，一般的圖片則稱為LDR \(Low Dynamic Range Imaging\)，簡單來說，前者可以儲存更大範圍的值，後者則只能儲存0~1，且只有256階。

但從我們的例子來看，理論上兩張圖的範圍都是0~1，基本上不會有太大差異，但是如果仔細看，你會發現有蠻大的差異。


![](/assets/8b414b22f7fb/1*funeiy1cpYvVmiiwS-g85g.png)



![圖3 LDR\(sRGB\) and HDR\(Linear\)](/assets/8b414b22f7fb/1*sfowxbeuPPPNWcDNPhl8KQ.png)

圖3 LDR\(sRGB\) and HDR\(Linear\)

左圖LDR其實比較符合0~1漸層的預期，右圖HDR的漸層則看起來有點不太平均，舉例來說，最下方的右半部幾乎都是相同的紅色，事實上，這樣的差異來自於color space，一般的圖片使用sRGB的color space，後者則是linear。

簡單來說，這兩張原始圖基本上在電腦中的數值幾乎是完全相同的，只是轉換到了不同的color space，也就是經過了不同的後處理，概念上，如果我們將HDR的圖片從Linear轉回sRGB理論上結果應該就會跟左圖LDR相同，因為它們原始圖的數值幾乎完全相同，然後經過相同的後處理計算，結果就應該很接近。


![](/assets/8b414b22f7fb/1*-B9YWmdwKsvlAlwGk3Nw-w.png)



![圖4](/assets/8b414b22f7fb/1*WuZfltQ11KnF-ImEh1slyQ.png)

圖4

要改變color space要先將這張圖片儲存。要注意這邊不能存成\.jpg或是\.png這種常見的格式，而是要存成HDR圖片，這邊我將它儲存成\.exr，另外， _Color depth_ 則可以選擇Half或是Full，後者就是上文敘述的，每個channel用32bit的float去儲存，所以又稱RGBA32F，前者則是使用16bit，雖然精度減半，但是基本上還是可以當作float使用，所以又稱RGBA16F。


![](/assets/8b414b22f7fb/1*JnAjB3GG3Zf9rFqczZzVgg.png)



![圖5\.1 HDR\(sRGB\)](/assets/8b414b22f7fb/1*gab6tVTv6ewR40w1ioHKhw.png)

圖5\.1 HDR\(sRGB\)

然後回到Blender就可以把color space改成sRGB，結果可以發現與LDR十分相似的結果，如果我們一樣檢視\(1, 0\)位置的資訊可以發現R = 0\.00393，此時就會困惑，畫面上幾乎一模一樣的顏色，在LDR說他是0\.05098，在HDR說他是0\.00393，所以到底哪個是正確的。


![圖5\.2 HDR\[0\] \[1\]](/assets/8b414b22f7fb/1*1W1uytsyR1EBYUkUeRhf6Q.png)

圖5\.2 HDR\[0\] \[1\]

事實上，畫面上顯示的顏色的數值應該是要看寫著CM的這一欄，它代表著這個顏色在Blender的Color Management設定下的值，預設是sRGB，可以理解成，Blender告訴顯示器R=0\.05就會顯示出圖1\.2與圖5\.2的暗紅色，Blender告訴顯示器R=0\.2478就會顯示成圖2\.2的亮紅色。

更細節來說，整個過程像是下面的轉換
```rust
LDR(sRGB):   0.05098 -> 0.05098 (sRGB)
HDR(Linear): 0.05    -> 0.05    (Linear)->  0.2478 (sRGB)
HDR(sRGB):   0.05    -> 0.00393 (Linear)->  0.0500 (sRGB)
```

再腳本中的原始值是0\.05，而儲存成貼圖並轉換到sRGB時，LDR對應的值是0\.05098，HDR\(Linear\)是0\.2478、HDR\(sRGB\)是0\.05。

其中，HDR\(Linear\)與HDR\(sRGB\)差異在於，對於原始值0\.05的理解，前者認定0\.05在linear space，後者則認定0\.05在sRGB space，因此最後轉換到sRGB顯示出來時結果不同。轉換可以使用


[![](https://physicallybased.info/images/meta/tools.webp)](https://physicallybased.info/tools/){:target="_blank"}


同時LDR\(sRGB\)、HDR\(sRGB\)的顯示值幾乎相同，因此他們的顏色也很接近，唯一的差別在於前者的精度誤差較高，但兩者都認定原始值0\.05在sRGB space，因此最後轉換到sRGB顯示出來時結果相同。


![](/assets/8b414b22f7fb/1*9AEBiHbEK1gIt1pCC-CkWw.png)



![](/assets/8b414b22f7fb/1*MZOba4EhyxLeQt6rM_LkwQ.png)


所以，不妨我們也可以把LDR改成linear space看看，可以看到左攔仍然顯示0\.05098，中欄CM顯示0\.2503，整個過程像是下面的轉換
```rust
LDR(Linear): 0.05098 -> 0.05098 (Linear)->  0.2503 (sRGB)
```

整個過程跟HDR\(Linear\)基本相同，其中比較需要補充的就是CM左邊的欄位顯示的基本上會跟你是LDR或是HDR，或者說使用8bit或是32bit儲存有關，前者直接顯示原始值，後者猜測是固定顯示Linear Space的RGB，可以參考Blender的說明。

[**Color Management — Blender Manual**](https://docs.blender.org/manual/en/latest/render/color_management.html){:target="_blank"} 
[_For correct results, different Color Spaces are needed for rendering, display and storage of images\. Rendering and…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/render/color_management.html){:target="_blank"}

這邊猜測是因為，就是在計算所有東西都應該在Linear Space，直到最後一步要顯示前才轉換到sRGB Space，另外，一般的圖片預設就是在sRGB，這是因為圖片通常不會做任何計算直接顯示出來。

至於更進一步Linear與sRGB的實際轉換牽涉到HDR的議題這就超出本篇的範圍，就不展開了。


[![](https://kaicho-cg.com/wp-content/uploads/2020/06/2000-real.jpg)](https://kaicho-cg.com/shading-srgb-raw/){:target="_blank"}



[![](https://i.imgur.com/JIDwVTm.png)](https://lettier.github.io/3d-game-shaders-for-beginners/gamma-correction.html){:target="_blank"}




_[Post](https://medium.com/maochinn/blender-%E5%AE%A2%E8%A3%BD%E5%8C%96%E5%BB%BA%E7%AB%8Btexture-8b414b22f7fb){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
