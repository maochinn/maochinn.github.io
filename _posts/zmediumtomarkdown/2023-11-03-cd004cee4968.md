---
title: "【電腦圖學】Half-texel Offset"
author: "帽捲"
date: 2023-11-03T14:33:48.121+0000
last_modified_at: 2023-11-03T14:33:48.121+0000
categories: ["Maochinn"]
tags: ["computer-graphics"]
description: "這篇要描述的問題則是一個平常不太會注意的問題，但是要了解何謂Texel以及Pixel"
image:
  path: /assets/cd004cee4968/1*yahNdLSfwmIAwFkWZSsXpQ.png
render_with_liquid: false
---

### 【電腦圖學】Half\-texel Offset

這篇要描述的問題則是一個平常不太會注意的問題，但是要了解何謂Texel以及Pixel，所謂的Pixel就是Picture Element的意思，那Texel就是Texture Element的意思，簡單來說Texel就是Texture中最小的一個單位。

那麼Picture\(又或者說Image\)與Texture又有甚麼不同呢？兩者都是2D array，Pixel是RGBA，Texel也是RGBA，撇開定義上的不同外，主要差異在於座標系統，Image的長寬取決於有幾個pixel，例如，一張1920x1080的Image，那麼Pixel的XY座標就會落在\[0~1079\] \[0~1919\]之間，但是Texture無論Texel有多少，Texel的UV座標會落在\[0\.0~1\.0\] \[0\.0~1\.0\]。

如何將Texel與Pixel對應可以參考如下


[![](https://learn.microsoft.com/en-us/media/open-graph-image.png)](https://learn.microsoft.com/en-us/windows/win32/direct3d9/directly-mapping-texels-to-pixels){:target="_blank"}


其中這張圖表示一個6x6 pixels的Image，Pixel都是坐落在整數點上，也就是\(x, y\) = \(0~5, 0~5\)，而不是想像中的Pixel會佔據整個1x1方形，因此，這張圖片實際上的長寬是7x7 \( \-0\.5~5\.5, \-0\.5 ~ 5\.5\)


![](/assets/cd004cee4968/0*do2NHLSBr8VgR4x2.png)


另一方面，Texture可以參考


[![](https://learn.microsoft.com/en-us/media/open-graph-image.png)](https://learn.microsoft.com/en-us/windows/win32/direct3d9/bilinear-texture-filtering){:target="_blank"}


以一張4x4 texels的texture為例，可以注意到他的座標範圍是\(u, v\)=\(0\.0~1\.0, 0\.0~1\.0\)，但是可以注意到，雖然Texel仍然是坐落在每個方形的中間，但是下圖左上角的Texel座標是\(0\.125, 0\.125\)，而上圖中左上角的Pixel座標是\(0\.0, 0\.0\)。


![](/assets/cd004cee4968/0*FtrgEYlDrfZlA3G5.png)



![](/assets/cd004cee4968/0*xl055LAFjZSBxkrz.png)


因此如果我們直接將Pixel的\(x, y\) normalize到0~1之間，以此當作UV，結果如下圖，你會發現不是你預期的結果，你會希望Texel能夠跟Pixel對齊，不希望會有一個留白的外框。


![](/assets/cd004cee4968/0*kUMjLKaeeHimVk8F.png)


一個表面的原因就是左上角的pixel落在\(0\.0, 0\.0\)，而左上角的texel則是落在\(0\.125, 0\.125\)，這樣的位移剛好相差半個texel的方格，所以在這篇討論中被稱之為 **Half\-texel Offset** ，這就是這篇主要探討的問題。


[![](https://forum.unity.com/attachments/403732/)](https://reurl.cc/edkjVW){:target="_blank"}


這篇文章提的問題就是當它使用Vertex的UV去採樣Texture畫到畫面\(Image\)，也就是左上角點的UV = \(0\.0, 0\.0\)，右下角點的UV = \(1\.0, 1\.0\)，這時會發現它會發現Texture是貼在黃框裡面，乍看是Texture有一個位移\(offset\)或是縮小了。


![](/assets/cd004cee4968/0*oATi6WaizcUqzVCm)


討論中以4x4的Image來舉例，我們預期Texture會占滿整個畫面，但實際因為Texture只占滿黃框的部分，除此之外的部分是一個半個方形的外框，它的顏色是黃框延伸出去的\(實際上取決於Filter\)，那這篇的目的就是解決這個問題。

一個最直覺的解決方式就是放大Texture半個方形，那就可以剛好填滿這個畫面，但是如此就需要對Texture本身做額外的處理，而且無論Texture本身的Texel有多少，它仍然在黃框內。

因此另一個做法就是縮小UV座標，以4x4的Image來舉例，我們將XY座標normalize之後可以產生這樣的UV座標，也就是將\(0~3, 0~3\) / \(3, 3\)，它採樣的結果就是上面的樣子。
```c
(0.0, 0.0) (0.3, 0.0) (0.6, 0.0) (1.0, 1.0)  // 0.0 = 0.0
(0.0, 0.3) (0.3, 0.3) (0.6, 0.3) (1.0, 0.3)  // 0.3 ~= 0.33333333333~
(0.0, 0.6) (0.3, 0.6) (0.6, 0.6) (1.0, 0.6)  // 0.6 ~= 0.66666666666~
(0.0, 1.0) (0.3, 1.0) (0.6, 1.0) (1.0, 1.0)  // 1.0 = 1.0
```

而實際上，我們的\(0\.0, 0\.0\)應該要去拿\(0\.125, 0\.125\)的texel，因為我們texel坐落的位置如下。
```scss
(0.125, 0.125) (0.375, 0.125) (0.675, 0.125) (0.875, 0.125)
(0.125, 0.375) (0.375, 0.375) (0.675, 0.375) (0.875, 0.375)
(0.125, 0.675) (0.375, 0.675) (0.675, 0.675) (0.875, 0.675)
(0.125, 0.875) (0.375, 0.875) (0.675, 0.875) (0.875, 0.875)
```

因此，我們可以應該大致寫出一個對應關係
```scss
(0.0, 0.0)  -> (0.125, 0.125)
(0.3, 0.3)  -> (0.375, 0.375)
(0.6, 0.6)  -> (0.625, 0.625)
(1.0, 1.0)  -> (0.875, 0.875)
```

事實上就是將UV的值域從\(0\.0~1\.0\)的縮小到\(0\.125~0\.875\)，也就是縮小掉0\.25，也就是將長度1縮小成0\.75，換言之，就是縮小一個方格，而一個方格的長寬=\(1\.0, 1\.0\)/Texel的橫縱數量。

以4x4為例，一個方格就是0\.25x0\.25，因此我們要縮小成1\-0\.25=0\.75，那就是乘上0\.75，也就是3/4，以此我們可以推廣以下的虛擬碼，其中W=橫向的texel數量，H表示縱向的texel數量。
```typescript
(u, v) = (u, v) - (0.5, 0.5)
(u, v) = (u, v) * ( (W-1)/W, (H-1)/H )
(u, v) = (u, v) + (0.5, 0.5)
```

至於為甚麼要先減去0\.5再加回0\.5這是因為我們縮小的中心是\(0\.5, 0\.5\)，詳細可以自己推導看看，總之，我們可以拿前面的例子來試試看。
```markdown
( 0.000 – 0.5 ) * (3/4) + 0.5 = 0.375
( 0.333 – 0.5 ) * (3/4) + 0.5 = 0.375
( 0.666 – 0.5 ) * (3/4) + 0.5 = 0.625
( 1.000 – 0.5 ) * (3/4) + 0.5 = 0.375
```

以此公式可以調整UV座標，讓Texture填滿整個畫面了。

接下來在Blender重現這個問題並且解決

首先，建立一個長21寬9的Grid，然後在Shader node中直接把UV當作顏色輸出，也就是左下角的RGB=\(0\.0, 0\.0, 1\.0\)、右上角的RGB=\(1\.0, 1\.0, 0\.0\)，把UV座標值當作RG的值，就會長得像這個樣子。


![](/assets/cd004cee4968/1*evEGbmh-NbRrebbnlEFWYg.png)


值得一提的是，如果你上網找UV coordinate可能會看到如下的圖，乍看之下跟上圖除了長寬沒什麼不同，但這邊有個小細節，就是Blender的UV看起來不是這麼的平滑似乎漸層的比較不平滑，例如底下紅色的部分似乎非常小，看起來不是平滑漸層上去的，導致看起來整張圖黃色占大多數。


![](/assets/cd004cee4968/0*5z6btJsPmrFhJkNL.png)


這是因為Blender在這邊顯示的是Linear空間上的顏色，而不是我們熟悉的Gamma空間，再往下會超出本篇範圍，這邊姑且就以Blender顯示為主。
