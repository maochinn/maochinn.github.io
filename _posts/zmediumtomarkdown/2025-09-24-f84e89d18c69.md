---
title: "【Omniverse Farm】學習筆記 — 02：Taipei-1"
author: "帽捲"
date: 2025-09-24T02:53:50.339+0000
last_modified_at: 2025-09-25T03:48:39.621+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","isaac-sim","ovx"]
description: "Taipei-1是NV建置的超級電腦，有兩種系統的機群，一個是有名的DGX，另一個是OVX，其中DGX，是Deep GPU Xceleration的意思，以此類推，OVX其實就是Omniverse Xceleration的意思，就如同【Omniverse Farm】學習筆記…"
image:
  path: /assets/f84e89d18c69/1*dBp5HikBtguPuVot4DWIKQ.png
render_with_liquid: false
---

### 【Omniverse Farm】學習筆記 — 02：Taipei\-1

Taipei\-1是NV建置的超級電腦，有兩種系統的機群，一個是有名的DGX，另一個是OVX，其中DGX，是Deep GPU Xceleration的意思，以此類推，OVX其實就是Omniverse Xceleration的意思，就如同 [【Omniverse Farm】學習筆記 — 00：OVX](../0fdb74ed85ce/) 中提到的，Taipei\-1 OVX就是透過Omniverse Farm來提交任務，好處是，使用者不需要自己管理實際執行的agent機群，由farm中的queue來調動。

所以我可以在windows本地發送task到遠端的Omniverse Farm，一種最簡單的方法就是使用 [【Omniverse Farm】學習筆記 — 01：Using Movie Capture to Render](../1745b2c60c07/) 中提到的方式，但這種方式明顯的只能用在rendering這樣的task上，主要的原因是因為，我們完全仰賴extension來幫我們submit task，我們不能做其他類型的task，例如模擬等。

另外，那個extension提交的task是 _create\-render_ ，這種task是基於 _kit\-service_ 這種job type，他會在omniverse kit的環境下運行task，但是有時我們的task未必需要在omniverse的環境下運行，例如對圖片作後處理等等，可能只是單純的python腳本，因此有另一個類型的job type稱之為 _base_ 。基於 _base_ 的task基本上就像是直接在terminal下command那樣的自由，這也包含運行omniverse，透過standalone。

因此，最根本的解決方式就是自己定義基於 _base_ job的task等，也就是我們在 [【Omniverse Farm】學習筆記 — 00：OVX](../0fdb74ed85ce/) 中做的事情，因為這樣我們可以自己決定在任意的環境\(Omniverse或不是\)下執行任意的腳本\(rendering或其他腳本\)，但這種方式也是最麻煩的，我們光從submit **_hello\-world_** task的過程就知道過程很繁瑣，因此，實作上，我們可以參考別人做的工具


[![](https://opengraph.githubassets.com/32debd05b9c804b07951dd14c320e938b38b7a04cf34bd17d737990a1294e46d/j3soon/omni-farm-isaac)](https://github.com/j3soon/omni-farm-isaac){:target="_blank"}


omni\-farm\-isaac這個repo其實就是將基本的omniverse farm的指令包裝成\.sh，例如 [教學](https://docs.omniverse.nvidia.com/farm/latest/guides/testing_farm.html){:target="_blank"} 中確認farm中有甚麼job type時會透過這個API
```bash
curl http://localhost:8222/queue/management/jobs/load
```

而在omni\-farm\-isaac中要確認jobs的時候就是直接執行
```bash
scripts/load_job.sh
```

我們可以在repo中找到對應檔案後，打開程式碼會發現這段
```bash
# Reference: https://docs.omniverse.nvidia.com/farm/latest/guides/creating_job_definitions.html#uploading-job-definitions
curl -X "GET" "${FARM_URL}/queue/management/jobs/load" \
    -H "Accept: application/json" \
    -H "Content-Type: application/json" \
    -H "X-API-KEY: ${FARM_API_KEY}" \
    | jq
```

其實基本上一樣都是去call API，差異在於scripts/load\_job\.sh中有具體寫明使用"GET"，但其實curl預設就是使用"GET"，所以教學中才沒有寫，但其實是一樣的東西。

總之，對應 [【Omniverse Farm】學習筆記 — 00：OVX](../0fdb74ed85ce/) 中常用的4個API
```bash
/queue/management/jobs/save
/queue/management/jobs/load
/queue/management/jobs/remove
/queue/management/tasks/submit
```

omni\-farm\-isaac/scripts/中就有提供對應的四個\.sh
```bash
scripts/save_job.sh
scripts/load_job.sh
scripts/remove_job.sh
scripts/submit_task.sh
```

其實就是對應OV farm的基本操作。

因此，本篇主要就是依據 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} 提供的工具來介紹如何實際submit任務到Taipei，主要是透過一個本地的Windows即可，除此之外，Taipei\-1是遠端的機器，因此腳本所需要的asset也要事先上傳到Nucleus Server，這個部分可以直接用瀏覽器或是透過 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} 中提供的omnicli來批量上傳，只不過後者只能在Linux環境下執行。

總之，操作的細節請參考 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} ，這邊只會紀錄重點。
### Submit a base task

那回到Windows要怎麼submit task，或者說怎麼跟遠端的queue互動，我們需要透過scripts/中的4個\.sh，但因為\.sh是不是windows預設可以跑的執行檔，我們可以透過 [git](https://git-scm.com/downloads){:target="_blank"} 自帶的git bash來執行這些\.sh。

在\.sh之中它會抓環境變數來用，所以在執行前要先設定好以下
```cpp
export FARM_API_KEY="s3cr3t"
export FARM_URL="http://localhost:8222"
export FARM_USER="j3soon"
export NUCLEUS_IP="127.0.0.1"
export NUCLEUS_HOSTNAME="localhost"
# Below are optional, only needed if you are using non-default username and password for Nucleus.
# export OMNI_USER="admin"
# export OMNI_PASS="admin"
# export FTP_USER="j3soon"
# export FTP_PASS="s3cr3t"
```

其實就是farm跟nucleus的位址，如果farm在本地端，那就是
```ini
FARM_URL="http://localhost:8222"
```

如果是在遠端，那就把路徑換成遠端位址即可，總之這些設定因為常常需要重新設定，所以建議手動把它儲存成secrets/env\.sh，之後就只需要呼叫
```bash
cd ~/Workspace/Corvus/Taipei-1/omni-farm-isaac
source secrets/env.sh
```

就可以設定好需要的環境變數了，之後就可以跑接下來的範例了，首先是定義一個名為echo\-example的job上傳並查看
```bash
scripts/save_job.sh echo-example
scripts/load_job.sh
```

這邊要注意的是，如果去看save\_job\.sh的內容可以發現，他其實是會使用job\_definitions/echo\-example\.json來做為job的定義後，然後傳到OV farm，換言之，如果要定義一個job，就要先寫好json，例如要定義一個hello\-world的job，那就要在事先寫好job\_definitions/hello\-world\.json。

或者，就是要使用官方網站的做法，也就是之前文章介紹的方法，將job寫成\.kit，然後用job\_definition\_upload\.py傳上去。

[**Testing Your Farm Instance \- Omniverse Farm**](https://docs.omniverse.nvidia.com/farm/latest/guides/testing_farm.html#uploading-to-farm){:target="_blank"} 
[_With your Farm instance up and running, you'll want to confirm that everything is functioning as it should\. This…_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/farm/latest/guides/testing_farm.html#uploading-to-farm){:target="_blank"}

總之，把job傳上去後，就可以執行
```bash
scripts/submit_task.sh echo-example "hello world" "Echo hello world"
```

應該在dashboard裡面可以看到task的log


![](/assets/f84e89d18c69/1*Exx5tUQXQCkwa9zORWeqhA.png)


那我們可以更深入的挖掘echo\-example\.json可以發現，基本上整體跟\.kit的格式類似，因為他們的功能都是定義job，節錄部分如下
```bash
{
  "job_type": "base",
  "command": "echo",
...
 "container": "ubuntu:latest",
  "allowed_args": {
    "args": {
      "arg": "",
      "default": "hello",
      "separator": ""
    }
  }
}
```

這邊就可以看到它的job type的確是 _base_ ，它的command是echo，args預設是hello，也就是如果task沒有給定args的話，那他其實就是執行
```bash
echo hello
```

但是我們submit的task有給定args為"hello world"
```bash
scripts/submit_task.sh echo-example "hello world" "Echo hello world"
```

因此，實際上是執行
```bash
echo hello world
```

並且將這個task註解”Echo hello world”


![](/assets/f84e89d18c69/1*v0OmI5mwi8-jKHKPfePh3Q.png)


只不過可以在json看到一些其他job的設定，包含使用甚麼樣的container去執行task，例如，ubuntu:latest，這個部分接下來的例子還會看到。
### Submit a task with isaac\-sim standalone script

像是下個例子要執行Isaac的standalone workflow下的python腳本，簡單來說就是會透過Isaac\-sim的python環境去執行Isaac的腳本，以此我們也可以用基於 _base_ 的task來執行Omniverse的功能
```bash
scripts/save_job.sh isaac-sim-dummy-example
scripts/submit_task.sh isaac-sim-dummy-example "./standalone_examples/api/isaacsim.core.api/time_stepping.py" "Isaac Sim Time Stepping"
```

首先，我們可以從isaac\-sim\-dummy\-example\.json知道command是
```json
"command": "./python.sh",
```

而加上task給定的args，他實際上就是在container中執行
```bash
./python.sh ./standalone_examples/api/isaacsim.core.api/time_stepping.py
```

其實就是只是呼叫python執行腳本而已，如果有在使用Isaac的standalone可以進一步發現，這個腳本呼叫的是Isaac\-sim中的範例腳本，事實上這個job用的container就是
```json
"container": "nvcr.io/nvidia/isaac-sim:4.5.0"
```

該container中除了包含完整的isaac\-sim之外，也包含了這個腳本，但是正常的情況下，欲執行的的腳本不會在container之中，我們需要從nucleus中下載到container，所以可以進到下一個範例。
### Submit a task with Nucleus

就如同之前提到的，nucleus的檔案要先從本地上傳，然後執行task的時候會在container中下載下來，至於上傳的方式有兩種，一個是直接使用瀏覽器上傳\(或者透過Omniverse中的Content也可以\)，另一種則是把 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} 下載到在Linux環境中，透過repo中的omnicli將檔案上傳到nucleus
```bash
source secrets/env.sh
cd thirdparty/omnicli
./omnicli copy "../../tasks/isaac-sim-simulation-example.py" "omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Scripts/isaac-sim-simulation-example.py"
cd ../..
```

使用方式很簡單，只是要記得設置環境變數，然後就可以將檔案從本地上傳到目標位址，只是有個小缺點是執行的時候不會有任何輸出，只要再完成的時候會輸出OK。

比較大的問題是windows的環境會沒辦法執行，一個比較暴力的解決方式就是直接透過nucleus的網頁版直接上傳到指定路徑即可，缺點是，如果是大量的檔案，而不是單個腳本這樣實在不是很有效率，所以可能需要wsl的環境，或者是需要自己build omnicli\.exe


[![](https://opengraph.githubassets.com/285f51815cad4c69fe13e99fc35402c2c7262cb1a304d009bf9c9545b4f7a91b/NVIDIA-Omniverse/connect-samples)](https://github.com/NVIDIA-Omniverse/connect-samples?tab=readme-ov-file#omni-cli){:target="_blank"}


總之，把檔案上傳上去後，就可以submit task
```bash
scripts/save_job.sh isaac-sim-basic-example
scripts/submit_task.sh isaac-sim-basic-example \
"/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Scripts/isaac-sim-simulation-example.py' \
  --download-dest '/src/isaac-sim-simulation-example.py' \
  --upload-src '/results/isaac-sim-simulation-example.txt' \
  --upload-dest 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Results/isaac-sim-simulation-example.txt' \
  './python.sh -u /src/isaac-sim-simulation-example.py 10'" \
  "Isaac Sim Cube Fall"
```

可以發現，他將一連串的command都寫在args中，這是因為在isaac\-sim\-basic\-example\.json中
```json
"command": "bash",
```

我們可以發現command是bash，而實際上的command都寫在task的args中，因此實際執行類似這樣
```dart
bash /run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Scripts/isaac-sim-simulation-example.py' \
  --download-dest '/src/isaac-sim-simulation-example.py' \
  --upload-src '/results/isaac-sim-simulation-example.txt' \
  --upload-dest 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Results/isaac-sim-simulation-example.txt' \
  './python.sh -u /src/isaac-sim-simulation-example.py 10'
```

換言之，這個task是在container中執行/run\.sh，他可以接受幾個參數，其中，download\-src和download\-dest，就是在啟動container的時候會將nucleus的src檔案下載到container中的dest目標路徑，以此類推，upload\-src和upload\-dest也是類似的概念，就是執行完腳本之後，會將container中的檔案上傳到nucleus，最後是要執行的腳本，以上面為例
```bash
./python.sh -u /src/isaac-sim-simulation-example.py 10
```

這才是真正要執行的腳本，同時也可以注意到，這個腳本的路徑跟download\-dest是相同的，換言之，為了要執行這個腳本，我們需要將它從download\-src\(in nucleus\)下載到download\-dest\(in container\)，然後要在正確的路徑下才能在container中找到這個腳本。

另外，在isaac\-sim\-simulation\-example\.py也可以發現
```python
pathlib.Path("/results").mkdir(parents=True, exist_ok=True)
with open("/results/isaac-sim-simulation-example.txt", "w") as file:
    file.write(output)
```

腳本中會寫檔案到/results/isaac\-sim\-simulation\-example\.txt，這個路徑是跟upload\-src是相同的，因此，在腳本執行完後才能正確地把container中輸出的檔案上傳到nucleus，否則輸出的檔案將會隨著container的關閉而消失。

接著讓我們來試一個類似的例子，我們一樣使用isaac\-sim中的範例腳本，
```bash
isaacsim/standalone_examples/api/isaacsim.replicator.examples/sdg_getting_started_01.py
```

它會利用replicator生成多張圖片，我們想要將在container中執行它，並且將輸出的圖片上傳到nucleus，只不過因為Taipei\-1屬於headless環境我們需要修改腳本
```ini
simulation_app = SimulationApp(launch_config={"headless": True})
```

也因為這個腳本是我們自己修改的，container中並沒有，所以還是需要上傳到nucleus再載到container中
```bash
scripts/save_job.sh isaac-sim-nucleus-example
scripts/submit_task.sh isaac-sim-nucleus-example \
"/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Scripts/sdg_getting_started_01.py' \
  --download-dest '/src/sdg_getting_started_01.py' \
  --upload-src '/isaac-sim/_out_basic_writer' \
  --upload-dest 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Results/_out_basic_writer' \
  './python.sh -u /src/sdg_getting_started_01.py'" \
  "Isaac Sim SDG TESTING"
```

值得注意的是，該腳本會將檔案輸出在
```bash
/isaac-sim/_out_basic_writer
```

因此我們會將 — upload\-src設定成這個路徑，細節可以自己找腳本來看，如果順利的話，執行完task應該就會necleus的對應路徑下發現一些圖片


![](/assets/f84e89d18c69/1*dBp5HikBtguPuVot4DWIKQ.png)

### Build a Docker Image for OV farm

不過，我們剛剛其實忽略了一個問題是，/run\.sh是從哪裡來的，他理論上是container中預先存在的，因為我們沒有傳送它進去。事實上，這是因為task是在特製的container中運作的，從isaac\-sim\-basic\-example\.json和isaac\-sim\-nucleus\-example\.json都可以發現
```json
"container": "j3soon/omni-farm-isaac-sim:4.5.0",
```

這並不是官方的image，它是 [omni\-farm\-isaac/Dockerfile\_isaac\_sim\_4\_5\_0](https://github.com/j3soon/omni-farm-isaac/blob/master/Dockerfile_isaac_sim_4_5_0){:target="_blank"}
```bash
# Tools and scripts for Omniverse Farm
COPY thirdparty/omnicli /omnicli
COPY scripts/docker/run.sh /run.sh
```

可以發現他在建立image的時候就先將需要用到的程式包進去了，事實上，只要跟隨 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac/tree/master){:target="_blank"} /Dockerfile\_general的規則，我們要submit的task就可以在任意的image中執行任意的腳本了，例如
```bash
scripts/submit_task.sh vizuro-nucleus-example \
"/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Users/gino_chang/rendering' \
  --download-dest '/workspace' \
  --upload-src '/rendering_result' \
  --upload-dest 'omniverse://$NUCLEUS_HOSTNAME/Users/gino_chang/result' \
  'ls' \
  'python render.py -c config/taipei_1_engines.yaml'" "render 53x1000 images with all textures"
```

render\.py這是一個完全與omniverse無關的腳本，我們只要事先把所有會用到的asset上傳到Nucleus，然後在job\( \.json\)中設定好要使用的command，並且特製自己需要的image到docker hub，在執行task的時候就會自己抓最新的下來了。
```dart
/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Users/gino_chang/rendering' \
  --download-dest '/workspace' \
  --upload-src '/rendering_result' \
  --upload-dest 'omniverse://$NUCLEUS_HOSTNAME/Users/gino_chang/result' \
  'ls' \
  'python render.py -c config/taipei_1_engines.yaml'
```

甚至，你可以注意到，在執行腳本之前還順便output當前目錄的內容在log中，到此，基本上就可以透過Omniverse farm任意的使用Taipei\-1去執行任意的腳本了，只是這個流程有個缺點是，所有要下載到nucleus的asset必須要放在同一個資料夾一起載到container中。

換句話說，目前為止，如果要在container中執行自己的腳本只有兩個手段，第一種，將腳本事先包到Image中，但顯然不太合理，第二種，就是透過nucleus在啟動container時透過omnicli下載到container中，顯然的，如果只是腳本這種空間不大的資料，這個時間可以忽略，可是如果是訓練集，那這種方式就顯得有點愚蠢。
### Submit a task with volume

因此，熟悉docker的人一定好奇能否mount一個volume，只要事先把檔案放在某個儲存空間，啟動container的時候在掛載上去就好， [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} 有提供一個方案是基於Kubernetes的omniverse farm。


[![](https://opengraph.githubassets.com/32debd05b9c804b07951dd14c320e938b38b7a04cf34bd17d737990a1294e46d/j3soon/omni-farm-isaac)](https://github.com/j3soon/omni-farm-isaac?tab=readme-ov-file#setting-persistent-volumes){:target="_blank"}


先說結論，你可以直接使用isaac\-sim\-volume\-example\.json這個job
```json
"volumes": [
      {
        "persistentVolumeClaim": {
          "claimName": "nfs-pvc"
        },
        "name": "nfs"
      }
    ],
    "volume_mounts": [
      {
        "mountPath": "/mnt/nfs",
        "name": "nfs"
      }
    ],
```

基本上只要使用這個job的task，其container中應該就可以看到有volume被掛載在/mnt/nfs這個路徑下。

那這邊稍微解釋一下發生了什麼事，實際上是isaac\-sim\-volume\-example的task在啟動的時候會透過nfs\-pvc，也就基於NFS協定的PVC\(Persistent Volume Claim\)去請求一個遠端的空間來掛，那這個遠端的空間稱之為PV\(Persistent Volume\)，至於這個PV是由管理員事先在Kubernetes中設置好的，所以你才能夠請求的到，同時管理員也應該要告訴你如何在offline的時候access，方便你隨時能夠上傳下載資料。


![[https://godleon\.github\.io/blog/Kubernetes/k8s\-Config\-StorageClass\-with\-NFS/](https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/){:target="_blank"}](/assets/f84e89d18c69/0*UWz3LBQJG8JvwCdT.jpg)

[https://godleon\.github\.io/blog/Kubernetes/k8s\-Config\-StorageClass\-with\-NFS/](https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/){:target="_blank"}

總之，我們可以透過以下的task去嘗試，將檔案輸出到/mnt/nfs中，然後自己在到該空間中檢查看看，這邊submit task的前置作業我就不贅述了，請自己參考repo
```bash
scripts/submit_task.sh isaac-sim-volume-example \
"/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Projects/$FARM_USER/Isaac/4.5/Scripts/isaac-sim-simulation-example.py' \
  --download-dest '/src/isaac-sim-simulation-example.py' \
  'ls /mnt/nfs' \
  'mkdir -p /mnt/nfs/results' \
  './python.sh -u /src/isaac-sim-simulation-example.py 10' \
  'cp /results/isaac-sim-simulation-example.txt /mnt/nfs/results/isaac-sim-simulation-example.txt'" \
  "Isaac Sim Cube Fall"
```

其中可以看到執行的部分，一開始先列出volume\(PV\)的內容
```bash
  'ls /mnt/nfs' \
  'mkdir -p /mnt/nfs/results' \
  './python.sh -u /src/isaac-sim-simulation-example.py 10' \
  'cp /results/isaac-sim-simulation-example.txt /mnt/nfs/results/isaac-sim-simulation-example.txt'" \
```

理論上應該在log中可以看見PV中的內容，例如
```bash
+ ls /mnt/nfs
hello.txt
hi.txt
```

然後後續的部分可以看到task在PV中創建一個資料夾result，執行為腳本後再將輸出的檔案複製到/mnt/nfs/result中，然後就直接關閉container，不再上傳資料到nucleus了。

甚至可以做一些騷操作，直接利用omnicli去直接下載nucleus檔案到volume
```bash
scripts/submit_task.sh isaac-sim-volume-example \
"/run.sh \
  --download-src 'omniverse://$NUCLEUS_HOSTNAME/Users/gino_chang/rendering/' \
  --download-dest '/mnt/nfs/workspace' \
  'ls /mnt/nfs'" \
  "Copy files from nuclues to volume"
```

換言之，假如我們有了volume後根本不需要nucleus的話，那我們也就根本不需要使用/run\.sh，因為它是為了我們方便執行腳本前後下載上傳資料到nuclues上，因此task可以簡化成
```bash
scripts/submit_task.sh vizuro-volume-example \
"python /mnt/nfs/rendering/render.py -c /mnt/nfs/rendering/config/taipei_1_volume_sample.yaml" "render 30x1000 images(512x512)"
```

根據官方文件跟repo的描述，我想Taipei\-1上這套omniverse farm應該就是基於Kubernetes的。 [omni\-farm\-isaac](https://github.com/j3soon/omni-farm-isaac){:target="_blank"} 應該本來也是內部使用的工具，後來才開放出來，因此設計上也比較沒有太多權限等防護機制，主要還是儘量提供彈性給開發者方便使用。

換言之，這些工具不確定在TPE\-1以外的機器適不適用，因為許多工具可能是基於一些設定好的環境，不過我們可以大概對於整個ov farm系統的運作有一個實際的認識。

最後整理一下一些我實際上用到的指令，基本上在Windows上是用git bash輸入以下指令
```bash
cd ~/Workspace/Corvus/Taipei-1/omni-farm-isaac
source secrets/env.sh
```

設定帳號密碼等環境，這樣後續的job, task才能夠成功上傳，這件事情每次重新開一個git bash都要做
```bash
scripts/save_job.sh vizuro-volume-example
scripts/submit_task.sh vizuro-volume-example \
"python /mnt/nfs/rendering/render.py -c /mnt/nfs/rendering/config/taipei_1_volume_sample_batch_1.yaml" "render 30x10000 images(512x512)"
```

這個例子是，我們submit的task的job名稱是vizuro\-volume\-example，應該要有對應的json，該task做的事情主要是執行在volume中的render\.py，該腳本使用一個yaml作為arg。
```bash
scripts/save_job.sh isaac-sim-volume-example
scripts/submit_task.sh isaac-sim-volume-example \
"time ./python.sh /mnt/nfs/isaacsim-api/synthesizer/generate_with_replicator_by_json.py --texture-dir '/mnt/nfs/textures/**/*.JPEG' --environment-dir '/mnt/nfs/environment_maps/1K/*.hdr' --usd-dir '/mnt/nfs/meshes/sample30/*.usd' --output-dir '/mnt/nfs/result/sample30/isaac' --config '/mnt/nfs/isaacsim-api/synthesizer/rendering_config/yunyan_model.json'" "render 30x10 images(960x540) with isaac-sim"
```

另一個例子是使用volume中的isaac\-sim python腳本，大致上差不多
```bash
scripts/save_job.sh isaac-sim-volume-example
scripts/submit_task.sh isaac-sim-volume-example \
"time ./isaac-sim.sh --allow-root --no-window --/omni/replicator/replicatorYaml/yamlPath=/mnt/nfs/isaacsim-api/synthesizer/simple_usd_synthesizer_volume.yaml" "render 50 images(1024x1024) with yaml workflow"
```

這是使用Omniverse中的Replicator，直接透過yaml來執行，不用寫腳本
```bash
scripts/submit_task.sh isaac-sim-volume-example \
"time /run.sh \
  'ls /mnt/nfs' \
  './isaac-sim.sh --allow-root --no-window --/omni/replicator/replicatorYaml/yamlPath=/mnt/nfs/isaacsim-api/synthesizer/full_texture_usd_synthesizer_volume.yaml'" \
  "render 10000 images(1024x1024) with yaml workflow"
```

這也是類似的例子，細節可以參考

[**Replicator YAML \- Omniverse Extensions**](https://docs.omniverse.nvidia.com/extensions/latest/ext_replicator/yaml_workflow.html){:target="_blank"} 
[_Replicator YAML is a streamlined workflow for creating Synthetic Data with Replicator and Omniverse\. The format uses…_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/extensions/latest/ext_replicator/yaml_workflow.html){:target="_blank"}

[**Replicator YAML Manual \- Omniverse Extensions**](https://docs.omniverse.nvidia.com/extensions/latest/ext_replicator/yaml_manual.html){:target="_blank"} 
[_NVIDIA Omniverse Launcher will be deprecated on October 1, 2025\. Visit here for more details\._ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/extensions/latest/ext_replicator/yaml_manual.html){:target="_blank"}

剩下的是一些其他的範例，但是大致邏輯都相同
```
scripts/submit_task.sh isaac-sim-volume-example \
"./python.sh /mnt/nfs/isaacsim-api/synthesizer/test_file_patterns.py \
    --texture-pattern '/mnt/nfs/textures/**/*.JPEG' \
    --environment-pattern '/mnt/nfs/environment_maps/1K/*.hdr'" \
  "check textures and maps"
scripts/submit_task.sh isaac-sim-volume-example \
"./python.sh /mnt/nfs/isaacsim-api/synthesizer/generate_yaml_config.py \
     --texture-dir '/mnt/nfs/textures/**/*.JPEG' \
     --environment-dir '/mnt/nfs/environment_maps/1K/*.hdr' \
     --output-dir '/mnt/nfs/result/sample30/yaml' \
     --output-yaml '/mnt/nfs/result/sample30/.yaml'" \
  "check textures and maps"
```

最後補充，怎麼build自己的image，這個部分與OV farm比較沒有直接相關
```bash
docker login
docker build -t maochinn/omni-farm-blender:3.6.14 .
docker push maochinn/omni-farm-blender:3.6.14
docker logout
```

感謝你的閱讀，如果你對我的文章對你有所幫助或是意見歡迎回覆，如果你想要支持我可以：
- 拍個手👋，或是分享一些想法💬
- [追蹤我的頁面](https://medium.com/@maochinn){:target="_blank"}
- [訂閱我的專欄](https://medium.com/maochinn){:target="_blank"}
- [透過LinkedIn聯繫我](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


或是觀看我其他系列文章
- [【Omniverse Farm】Omniverse Farm學習筆記 — 00：OVX](../0fdb74ed85ce/)
- [【Omniverse Farm】學習筆記 — 01：Using Movie Capture to Render](../1745b2c60c07/)
- [【Omniverse】學習筆記 — 00：Kit\-based Development](../a54ae65f22bf/)
- [【Omniverse】學習筆記 — 03：OpenUSD](../be14a4a5704f/)



_[Post](https://medium.com/maochinn/omniverse-farm-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-02-taipei-1-f84e89d18c69){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
