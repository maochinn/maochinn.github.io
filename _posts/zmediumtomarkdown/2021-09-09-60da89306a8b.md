---
title: "【筆記】Transform Feedback Object"
author: "帽捲"
date: 2021-09-09T06:53:57.451+0000
last_modified_at: 2022-09-03T13:26:32.978+0000
categories: ["Maochinn"]
tags: ["computer-graphics"]
description: "先講我一開始的目的，因為我在geometry shader產生了一些新的primitive，然後我想把這些vertex拿出來，這件事情OpenGL有提供這樣的工具。"
image:
  path: /assets/60da89306a8b/0*e0IOXJ-71IwuFcFQ
render_with_liquid: false
---

### 【筆記】Transform Feedback Object

先講我一開始的目的，因為我在geometry shader產生了一些新的primitive，然後我想把這些vertex拿出來，這件事情OpenGL有提供這樣的工具。

不準確的來說就是GL在Rasterisation或者是說在fragment shader之前，我們可以先把所有的vertex都先寫到一個buffer裡面，然後我們可以在把這個buffer的東西拿出來\(GPU\-&gt;CPU\)。比較準確的東西可以看下圖。


![](/assets/60da89306a8b/0*e0IOXJ-71IwuFcFQ)


這邊就跳過一些基本的東西，大部分網路上都找的到一些文章，我有參考到的文章放在文末，但是中文的文章大多數提到的都是比較舊的用法，所以我們就先來看看舊版基本的操作，然後再看看新版的操作。

首先，先看看shader的部分。


![](/assets/60da89306a8b/1*IPoYIOk5Wk-wXPQlFc1uAA.png)


這邊只是把position的位置放大成2倍，然後uv直接拿position的xy，這邊只是方便做測試用而已。這邊可以注意到，我把gl\_Position拿掉了，因為我們並不需要往後傳到fragment shader，這個後面也會提到。

然後在建shader記得加上這幾行


![](/assets/60da89306a8b/1*bpUf0RCAAXk-edXz300qLw.png)


這邊的名子要對應shader裡面的position，參數分別是shader id、有2個要輸出的屬性、給定的屬性名稱、我們要將屬性分開到2個buffer。詳細可以自己到 [API的頁面](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml){:target="_blank"} 看，總之就是要告訴GL有哪些屬性要輸出到transform feedback buffer。

額外提一下，你可以先普通的把shader建完\( _glLinkProgram_ 完\)，然後再加上這幾行重新 _glLinkProgram_ 。

所以我們會需要兩個buffer來接這些屬性，那按照GL的邏輯buffer又會需要object去管理，就像是VAO跟VBO，所以理所當然，這邊會有TFO\(transform feedback object\)跟TBO\(transform feedback buffer object\)。

那要怎麼建TFO跟TBO? 為求方便我寫了簡單的struct


![](/assets/60da89306a8b/1*K2H60fvBTKZhlRzMKUR8wg.png)



![](/assets/60da89306a8b/1*Kwkp3OQrV0jJb1tT8PfesQ.png)


其實這個東西大致上就跟VAO VBO是類似的關係，因為我要有2個buffer，所以我就產生2個TBO，比較不同的是，你需要預先分配空間，也就是說你必須預先知道geometry shader完產生出來的vertex有多少個，如果你想完整拿到，那你必須至少分配足夠的空間出來，也就是這邊對應到的count。假設今天我會輸出兩個三角形，那我這邊的count應該要是2。

那最後，就是要怎麼render了。


![](/assets/60da89306a8b/1*GmZwBgc4DKuhT36BD32boQ.png)


首先，那個query的部分可寫可不寫，只是大多數的範例都會補這個東西用來檢查到底輸出了多少個primitive。第二個是 _GL\_RASTERIZER\_DISCARD_ ，這個東西會讓你跳過fragment shader，因為我們只需要transform完的vertex就好，所以這個東西才叫做transform feedback。

接下來就是要告訴GL要用哪個TFO去接\(就像是要用哪個VAO去畫\)，然後要用哪個primitive去接，這邊我們輸出是三角形就用 _GL\_TRIANGLES_ 。可以注意到這邊的寫法也是begin, end的邏輯。接下來就是query的begin, end，然後正常的把VAO畫出來。

如果一切正常，那麼position跟uv都會再對應的buffer中，那接下來就是要怎麼拿出來。


![](/assets/60da89306a8b/1*jcDleWOdu8dbeKpbaY2yMQ.png)


首先你可以先利用query拿到總共畫了幾個primitive到TFO，然後利用 _glGetBufferSubData_ 拿到buffer的資料。

到此為止，這些是舊版的操作，也就是如果你找網路上大多數的文章的操作，那新版的操作是什麼呢?

唯一的改動就是我們不用在事先給定varying的名稱，也就是不用事先再寫 _glTransformFeedbackVaryings。_

這個改動也很直覺，因為就像是過去的vertex shader的輸入並不是使用 _in_ ，而是 _attribute_ ，需要透過 _glGetAttribLocation_ 來拿到變數在GPU的位置，但是後來的版本可以直接在shader中定義\(In\-shader specification\)哪個變數對應哪個buffer\(VBO\)， 就像是我們會寫 _layout\(location = 0\)_ 。

所以改動就是在GLSL 4\.4版之後，我們可以這樣寫。


![](/assets/60da89306a8b/1*gyfvjSUbEZWdu4bvJ1xdeg.png)


也就是position對應第0個TBO，uv對應第1個TBO，其他參數設定可以自己去看文件，這邊只是簡單的示範流程。

總的來說，我們可以利用shader計算每個vertex，然後輸出出來，進一步來說，我們可以利用shader來利用GPU計算東西，也有其他應用例如particle system，傳統的做法就是CPU更新\-&gt;GPU畫出來，CPU與GPU的傳輸是非常耗費時間的，所以我們可以GPU更新、畫出來\-&gt;GPU更新、畫出來，我們就可以不用傳到CPU了。

也就是說，我們可以把TBO當成是VAO，再利用glDrawArrays把東西畫出來，但是這邊可以注意到glDrawArrays需要輸入count，也就是vertex的數量，這就表示我們可能需要使用query來把數量記錄起來，但這件事情又會造成GPU\-&gt;CPU這個問題，所以官方有以下描述去改善


> Feedback objects record the number of vertices that they captured in a feedback operation\. Note that a feedback operation is only complete when [glEndTransformFeedback](https://www.khronos.org/opengl/wiki/GLAPI/glEndTransformFeedback){:target="_blank"} is called, so you must first call that before trying to use this data\. 





也就是說，GL會紀錄vertex的數量，然後用 _glDrawTransformFeedback_ 取代 _glDrawArrays_ 來畫，所以如果我們想直接把TBO的內容直接畫出來，我們可以加幾行。


![](/assets/60da89306a8b/1*oxTH_aao3uy1uAVf36HonA.png)


首先，先將已經綁定為transform feedback buffer再綁定成VAO的VBO，你可能會懷疑這樣會不會衝突，但是對於GL來說，buffer本質上都是相同的， _glBindBuffer_ 只是將這個buffer bind到狀態機的對應位置，這點也可以發現無論是甚麼buffer都是用glGenBuffers產生，而且無須告訴GL是甚麼型態。

但是像是VAO, XFO, FBO之類的都有各自的函數，也就是說他們本質上就不一樣，他們都是不同型態的object。接下來，要畫出來的時候就只要這樣寫


![](/assets/60da89306a8b/1*yUIEOpu-LvxArqAkavNdsg.png)


可以注意到VAO還是要建立，所以概念上就跟操作VAO的邏輯是一樣的 _glDrawTransformFeedback_ 則是要把XFO輸入進去，這樣他才能去查count之類的資訊。另外既然他跟VAO的操作邏輯一樣，我們仍然可以用 _glDrawArrays_ 來畫，例如我們只畫出特定一個三角面。


![](/assets/60da89306a8b/1*XqUnyZKAB7ekHFfZ7YoNag.png)


[**Particle System using Transform Feedback**](https://ogldev.org/www/tutorial28/tutorial28.html){:target="_blank"} 
[_Particle System is a general name of a large number of techniques that simulate natural phenomena such as smoke, dust…_ ogldev\.org](https://ogldev.org/www/tutorial28/tutorial28.html){:target="_blank"}

[**GPU粒子与Stream Output\(Transform Feedback\)**](https://zhuanlan.zhihu.com/p/73895273){:target="_blank"} 
[_阐述GPU粒子的一些概念与基本原理，主要是英文教程的理解 粒子系统主要是用来模拟一些自然现象，例如烟，雾，烟花，雨等。涉及到大量的粒子的渲染，这些粒子可以是点，可以是小面片，本文介绍，结合Geometry \. \. \._ zhuanlan\.zhihu\.com](https://zhuanlan.zhihu.com/p/73895273){:target="_blank"}

值得一提的是，我可不可以仍然使用fragment shader，也就是不要開啟GL\_RASTERIZER\_DISCARD，答案是當然可以，所以我們可以正常的render東西，然後順便把東西也輸出到TBO，然後需要的時候再把東西從TBO拿出來就好。

另外，我們在shader裡面會習慣用Interface Block，如果是舊版的操作，我們要這樣寫，我們要給的是block的名稱\(G\_OUT\)而不是變數的名稱\(g\_out\)。


![](/assets/60da89306a8b/1*WEfRSuQ_FxzIeVf-wiH27A.png)



![](/assets/60da89306a8b/1*UT_Cg_H_SUji9KBJb5jw9A.png)


那如果我們想用新版的寫法，如果照下面那樣寫會跳錯。原因是一個block都會輸出到同一個buffer，頂多只能調整offset之類的。


![](/assets/60da89306a8b/1*42uZxRrVzqmG8dyA_bbBVw.png)


最後額外提一點，當我們用out輸出的時候，他同時會把position, uv輸出到TBO跟fragment shader，重點是這兩個是獨立的，也就是說，就算你畫出來是對的，但是有可能因為TBO空間分配不足，導致TBO的primitive數量不一致。

舉例來說，我們畫2個三角形，接position的TBO總共需要6個float，如果我們只給4個float，那你用query去拿primitives的值時會發現值為1，TBO的內容也只有一個三角形，因為第二個三角形空間不足，所以整個三角形的值都不會輸出。但是由於fragment shader的buffer是獨立的，所以畫出來的還是正常的兩個三角形。

[**Transform Feedback**](https://www.khronos.org/opengl/wiki/Transform_Feedback){:target="_blank"} 
[_Transform Feedback is the process of capturing Primitives generated by the Vertex Processing step\(s\), recording data…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Transform_Feedback){:target="_blank"}

[**john\.87\.connor \- Capture To Multiple Buffers**](https://sites.google.com/site/john87connor/transform-feedback/capture-to-multiple-buffers){:target="_blank"} 
[_Vertex Shader: \#version 450 core layout \(location = 0\) in vec3 in\_vertex; layout \(xfb\_buffer = 0, xfb\_offset = 0…_ sites\.google\.com](https://sites.google.com/site/john87connor/transform-feedback/capture-to-multiple-buffers){:target="_blank"}


[![](https://jvm-gaming.org/uploads/default/original/2X/5/519dabef9ca6a380693da0f403cc9a9ecfe1a479.png)](https://jvm-gaming.org/t/opengl-transform-feedback/40137){:target="_blank"}


[**OpenGL \- Transform Feedback**](https://open.gl/feedback){:target="_blank"} 
[_Up until now we've always sent vertex data to the graphics processor and only produced drawn pixels in framebuffers in…_ open\.gl](https://open.gl/feedback){:target="_blank"}


[![](https://nbertoa.wordpress.com/wp-content/uploads/2016/02/cube.png)](https://nbertoa.wordpress.com/2016/02/02/instancing-vs-geometry-shader-vs-vertex-shader/){:target="_blank"}




_[Post](https://medium.com/maochinn/%E7%AD%86%E8%A8%98-transform-feedback-object-60da89306a8b){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
