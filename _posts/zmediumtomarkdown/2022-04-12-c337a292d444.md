---
title: "【筆記】Coverage and Alpha"
author: "帽捲"
date: 2022-04-12T07:09:42.545+0000
last_modified_at: 2022-04-12T09:11:09.287+0000
categories: ["Maochinn"]
tags: ["computer-graphics"]
description: "紀錄一下這個老技術"
image:
  path: /assets/c337a292d444/1*9Ja2zNobcsKpFS_4weJ0IQ.png
render_with_liquid: false
---

### 【筆記】Coverage and Alpha

紀錄一下這個老技術

//施工中

在unity似乎叫做AlphaToMask

先提一些概念，GL在multi\-sampling並不是per sample的調用fragment shader，而是per fragment的調用fragment shader，如果是後者的話那就會是super\-sampling。那問題是，既然是per fragment，那每個sample的值是什麼，簡單來說就是把fragment的值複製給有被cover的sample。

[**Fragment Shader**](https://www.khronos.org/opengl/wiki/Fragment_Shader#System_inputs){:target="_blank"} 
[_OpenGL Rendering Pipeline A Fragment Shader is the Shader stage that will process a Fragment generated by the…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Fragment_Shader#System_inputs){:target="_blank"}

我們可以在fragment shader的input發現有以下input


![](/assets/c337a292d444/1*9Ja2zNobcsKpFS_4weJ0IQ.png)


這邊你可能會疑惑，為什麼會有gl\_SampleID，因為這意味著每個sample都會個別調用fragment shader，所以你可以看到下面的敘述


> Warning: Any use of this variable at all will force this shader to be evaluated per\-sample\. Since much of the point of multisampling is to avoid that, you should use it only when you must\. 





意思就是說如果你用了這個變數就會變成per sample的調用，意味著退化成super\-sampling，也就是說效能會下降，所以有必要時才使用。

Coverage and Alpha，或者說C2A是一個老技術，所以GL其實是有內建的，而他的實作是依據一些底層硬體實作會有不同。


> This is activated by using **glEnable\(GL\_SAMPLE\_ALPHA\_TO\_COVERAGE\) \.** When activated, **the alpha value will manipulate the coverage mask, such that an alpha of 1\.0 represents full coverage and a value of 0\.0 represents no coverage\.** 





實作上的差異就是我們要將一個fragment的alpha值想辦法分配給4\(假設採樣=4\)個sample，那這個分配在實作上會變成一個mask，這個mask會是4個bit的，也就是每個sample只分配到1個bit，意即0或1。舉簡單的例子就是alpha=0 \-&gt;0000，alpha=1\-&gt;1111，那麻煩的例子就是alpha=0\.5究竟要是0011, 0101, 1001, 0110…那一種，這個就是每個硬體實作的不同。

但概念上來說，如果alpha=0\.5，那這個mask就是要讓50%的sample被保留，因為是機率，所以這就有隨機性，也就有人要用dithering的概念來解，所以這個mask也會有人說是dither mask。

[**Multisampling**](https://www.khronos.org/opengl/wiki/Multisampling#Coverage){:target="_blank"} 
[_Multisampling is a process for reducing aliasing at the edges of rasterized primitives\. Aliasing is a signal processing…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Multisampling#Coverage){:target="_blank"}

在GL要怎麼用

`GL_SAMPLE_ALPHA_TO_COVERAGE`


> If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location\. The temporary coverage value is then ANDed with the fragment coverage value\. 





\(這邊跟上面的敘述有點矛盾，我還不太確定，因為他寫每一bit的值是依據每個sample的alpha而定，這就意味著每個sample都要算出alpha值，那就變成per sample的調用。\)

上面那段當我在胡言亂語，誤解是因為英文看錯了，他寫的意思是會利用alpha value產生一個mask，mask中的每個bit對應一個sample，我們可以看另個敘述更清楚。


> If conversion of alpha values to masks is enabled \( [glEnable](https://www.khronos.org/registry/OpenGL-Refpages/es1.1/xhtml/glEnable.xml){:target="_blank"} with argument `GL_SAMPLE_ALPHA_TO_COVERAGE` \), the fragment alpha value is used to generate a temporary modification mask which is then ANDed with the fragment mask\. One way to interpret this is as a form of dithering: a multivalued alpha \(coverage or opacity\) for the whole fragment is converted to simple binary values of coverage at many locations \(the samples\) \. 





原則上就是前面寫的意思。


> The alpha value of color number 0 \(index 0\) generated by the fragment shader can also be set to manipulate the coverage mask \( **this feature predates gl\_SampleMask and is less capable and more hardware\-dependent, so you should just modify the sample mask directly if you can** \) \. 





這邊可以注意到GL有建議你可以自己實作藉由gl\_SampleMask，可以看以下的連結

[**i965,iris,anv: Make alpha to coverage and alpha test work with sample mask \( \!292\) · Merge requests…**](https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/292){:target="_blank"} 
[_i965,iris,anv: Make alpha to coverage and alpha test work with sample mask From "Alpha Coverage" section of SKL PRM…_ gitlab\.freedesktop\.org](https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/292){:target="_blank"}

glSampleCoverage

GL\_SAMPLE\_ALPHA\_TO\_COVERAGE

gl\_SampleMask

[**Transparency Sorting**](https://www.khronos.org/opengl/wiki/Transparency_Sorting){:target="_blank"} 
[_Blending can be used to make objects appear transparent\. However, blending alone is not enough\. There are a number of…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Transparency_Sorting){:target="_blank"}

[**Fragment Shader**](https://www.khronos.org/opengl/wiki/Fragment_Shader){:target="_blank"} 
[_OpenGL Rendering Pipeline A Fragment Shader is the Shader stage that will process a Fragment generated by the…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Fragment_Shader){:target="_blank"}

[**Multisampling**](https://www.khronos.org/opengl/wiki/Multisampling#Coverage){:target="_blank"} 
[_Multisampling is a process for reducing aliasing at the edges of rasterized primitives\. Aliasing is a signal processing…_ www\.khronos\.org](https://www.khronos.org/opengl/wiki/Multisampling#Coverage){:target="_blank"}


[![](https://miro.medium.com/v2/resize:fit:640/1*zu3SAj1FZ1C8cUyBDvCTUQ.png)](https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f){:target="_blank"}


[**Oculus工程师分享：常见渲染问题，及发现问题、解决问题的方法**](https://cloud.tencent.com/developer/news/429126){:target="_blank"} 
[_查看引用/信息源请点击：映维网 常见的渲染问题，以及发现问题和解决问题的方法 （ 映维网 2019年08月28日…_ cloud\.tencent\.com](https://cloud.tencent.com/developer/news/429126){:target="_blank"}
