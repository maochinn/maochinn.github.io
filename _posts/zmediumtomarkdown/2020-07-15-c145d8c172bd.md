---
title: "【電腦圖學】學習筆記 — 02：Frame Buffer"
author: "帽捲"
date: 2020-07-15T06:17:49.048+0000
last_modified_at: 2024-09-28T10:47:45.249+0000
categories: ["Maochinn"]
tags: ["computer-graphics","電腦圖學"]
description: "無論用什麼樣的render pipeline，我最後都要使用點陣圖來顯示，也就是pixel的二維陣列，所以在CG的pipeline就有Rasterization這個步驟，然後在輸出到screen，或者說是window, viewport。"
image:
  path: /assets/c145d8c172bd/0*Qx0j0bhfOF9JS4gh.png
render_with_liquid: false
---

### 【電腦圖學】學習筆記 — 02：Frame Buffer

[&lt;【電腦圖學】學習筆記 — 01：Transformation](https://medium.com/maochinn/%E9%9B%BB%E8%85%A6%E5%9C%96%E5%AD%B801-transformation-%E6%96%BD%E5%B7%A5%E4%B8%AD-ea46dedf01f9?source=---------19-----------------------){:target="_blank"}

無論用什麼樣的render pipeline，我最後都要使用點陣圖來顯示，也就是pixel的二維陣列，所以在CG的pipeline就有Rasterization這個步驟，然後在輸出到screen，或者說是window, viewport。


![](/assets/c145d8c172bd/0*F2zQ78l3oJJxLwK_.png)

### Rasterization

光栅化，可以理解為將圖形轉換成以pixel為單位的座標空間，因為我們的顯示器大多是以這樣的方式來顯示的，那其實在在這之間其實還會經過Frame Buffer，你可以想像render都在GPU中，但是我們顯示器是要拿Main Memory的資料來顯示，所以我們在另一塊記憶體用一個Frame Buffer先來存這些render好的圖片，然後在一起傳到Main Memory，然後OS再將資訊交給Window System顯示在螢幕上。


![](/assets/c145d8c172bd/0*Qx0j0bhfOF9JS4gh.png)


所以通常這個部分就是幫你開window的lib會幫你處理，例如glut, glfw，因為這邊的操作就比較跟CG無關了。


![OpenGL Frame Buffer](/assets/c145d8c172bd/0*P0REn6Y4XoYHrzg5.jpg)

OpenGL Frame Buffer

那麼，現在我們關心的是Frame Buffer是甚麼？Frame Buffer包含所有要顯示在輸出裝置上的資訊，而前面有提到輸出裝置通常是透過 [點陣圖](https://ref.gamer.com.tw/redir.php?url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%BD%8D%E5%9B%BE){:target="_blank"} 顯示，意即大量的格子，而每一格如何顯示又主要由以下三種Buffer提供的資訊所組成，你可以想像成每個pixel有多個channel，例如:R、G、B、A\. \. \.。
#### Color Buffer

也就是儲存顏色的空間，通常又分成RGB\(紅綠藍\)3個channel，他可以決定該點的顏色\(RGB可以混合出絕大多數人類可見的顏色\)，Color Buffer的值常使用Unsigned char\(0~255\)或是Float\(0\.0f~1\.0f\)儲存，以Unsigned char來說，\(255, 0, 0\)就是鮮豔的紅色。值得一提的是常常也會使用4通道RGBA，也就是增加一個「透明」的通道。

補充一下，這邊之所以有分兩種方式就是如果我們需要比較精細的計算時可以使用Float，而之所以是0\.0~1\.0，而不是其他範圍是因為在0~1的範圍內互乘仍然會在0~1之間，所以可以避免掉值會越算越大\(發散\)的數值誤差。
#### Depth Buffer

紀錄該格的深度。所謂的深度是用來紀錄深淺，也就是這個pixel對應的點與相機的距離，因為在一個三維空間中過轉換可能會有兩點重疊，而通常我們傾向於顯示距離相對近的點，也就是靠近相機的東西會擋住後面的東西。


![](/assets/c145d8c172bd/1*5zjuiIz9wmHr4QJaffXahg.png)


這邊補充一點，這種演算法稱為hidden\-surface\-removal algorithm，使用z\-buffer\(也就是這邊的depth buffer\)來判斷前後位置，在OpenGL中是可以決定是否使用深度測試，而通常我們要render透明的東西就必須把深度測試關閉，因為我們需要拿多個點混合才能得正確的顏色，反過來說我們就必須要依照遠到近來render。
#### Stencil Buffer

可以決定這個pixel需不需要被繪製，通常是我們只需要部分pixel被繪製，例如被UI檔住，那這部分的pixel就不需要浪費資源去render。


![](/assets/c145d8c172bd/0*MfYRTAq3OVZXfsva.png)


所以我們可以回頭看看OpenGL pipeline，當我們rasterization完後就會產生很多個fragment，或者你可以想像成是pixel。


![](/assets/c145d8c172bd/0*Ic7hy65VXa57mbRd.png)


這邊其實就可以說說什麼叫fragment了，就廣義上來說，fragment跟pixel是一樣的，但就狹義來說，pixel就是picture element，最多就是RGBA，相反的，可以有任何資料來存在fragment裡面，也就是它可以不是RGBA之類的。

這邊值得注意的是，前面提到的3種Buffer就有3種與之相關的test，就是Alpha Test, Depth Test, Stencil Test，其實就是利用對應的值來決定這個pixel到底會不會受到影響，例如depth test就是檢查深度值大小，如果比較小\(比較靠近相機\)那就把這個Pixel的顏色換成比較小深度值的fragment的顏色。那這三種test其實就是屬於Per Fragment operations。

但其實這中間又分成兩種，Early Fragment Test跟Late Fragment Test，前者表示rasterization完就直接執行各種Test，然後再針對每個fragment來計算完整結果\(例如RGB\)，後者則是相反，rasterization完直接計算fragment完整結果，然後在依據資訊執行test。舉例來說，early depth test就是在計算這個fragment的顏色之前，我們就直接先比深度值，如果深度值大於目前位置的深度值，那就直接丟棄\(discard\)。另一個就是先計算完這個fragment的顏色然後再比對深度值，再決定要不要discard。


![](/assets/c145d8c172bd/0*AfxTchjY7kkcLfrE)


這邊可以先把fragment shader當作是計算fragment顏色的步驟。

很明顯的，前者的效率比較高，因為可以先篩選掉不必要計算的fragment，而後者可能會計算了許多會被discard的fragment，不幸的是，OpenGL預設的為後者，也就是說，理想上depth test可以避免浪費效能，但事實上我們仍然會畫所有的fragment然後在discard。

另外，還可以提到一點，因為我們是把東西畫到Frame Buffer，不一定要顯示出來，所以我們可以offline的把東西render到frame buffer，然後我們在直接從frame buffer把我們所需的buffer。所以在OpenGL 3\.0之後有了Frame Buffer Object，可以指定render的目標為任意的frame buffer。
### 延伸閱讀

[【電腦圖學】學習筆記 — 03：Shading](https://medium.com/maochinn/%E9%9B%BB%E8%85%A6%E5%9C%96%E5%AD%B8-shading-515575499065?source=---------17-----------------------){:target="_blank"}

[【](../9227dafc2f9c/) [電腦圖學](../ea46dedf01f9/) [】OpenGL：Pick](../9227dafc2f9c/)

[【](../9227dafc2f9c/) [電腦圖學](../ea46dedf01f9/) [】OpenGL：](../9227dafc2f9c/) [Transform Feedback Object](../60da89306a8b/)

[【](../264c31c43921/) [電腦圖學](../ea46dedf01f9/) [】Differentiable Rendering](../264c31c43921/)

[【Blender】Geometry Node 像素風](https://medium.com/maochinn/blender-geometry-node-%E5%83%8F%E7%B4%A0%E9%A2%A8-1870e1ad5fc3?source=---------4-----------------------){:target="_blank"}



_[Post](https://medium.com/maochinn/%E9%9B%BB%E8%85%A6%E5%9C%96%E5%AD%B8-frame-buffer-c145d8c172bd){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
