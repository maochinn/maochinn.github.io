---
title: "„ÄêOmniverse„ÄëDevelopment 102: Learning OpenUSD"
author: "Â∏ΩÊç≤"
date: 2024-11-27T14:26:31.991+0000
last_modified_at: 2024-12-26T08:59:04.546+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","openusd"]
description: "In the previous article, „ÄêOmniverse„ÄëDevelopment 101: Kit Workshop SIGGRAPH 2022, we manually modified the¬†.usda file. We can know that all‚Ä¶"
image:
  path: /assets/59dee6c16bd5/0*09cRzp4gjAR9xJv2
render_with_liquid: false
---

### „ÄêOmniverse„ÄëDevelopment 102: Learning OpenUSD

‰∏≠ÊñáÁâàÊú¨: [„ÄêOmniverse„ÄëÂ≠∏ÁøíÁ≠ÜË®ò ‚Äî 03ÔºöOpenUSD](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f?source=---------0-----------------------){:target="_blank"}

In the previous article, [„ÄêOmniverse„ÄëDevelopment 101: Kit Workshop SIGGRAPH 2022](https://medium.com/maochinn/omniverse-development-101-kit-workshop-siggraph-2022-310a189add0b?source=---------0-----------------------){:target="_blank"} , we manually modified the \.usda file\. We can know that all objects in Omniverse, or more accurately, Prim\(itive\), are all through OpenUSD to modify, whether directly modifying the \.usd file or using the OpenUSD API\.

Therefore, before entering the more advanced application of Kit\-based Omniverse, we must further learn OpenUSD\. This is because, rather than saying that Omniverse is a software that can import and export \.usd files, it is better to say that Omniverse is a software based on OpenUSD\.

The Banner on the official website describes NVIDIA Omniverse like this\.


> The platform for developing **OpenUSD** applications for industrial digitalization and generative physical Al\. 






![[https://www\.nvidia\.com/en\-us/omniverse/](https://www.nvidia.com/en-us/omniverse/){:target="_blank"}](/assets/59dee6c16bd5/0*09cRzp4gjAR9xJv2)

[https://www\.nvidia\.com/en\-us/omniverse/](https://www.nvidia.com/en-us/omniverse/){:target="_blank"}

Omniverse is a platform on which OpenUSD applications can be developed\. In other words, both the Application and Extension mentioned in [„ÄêOmniverse„ÄëDevelopment 101: Understanding Applications and Extensions](https://medium.com/maochinn/omniverse-development-101-understanding-applications-and-extensions-1d990d98b7f9?source=---------3-----------------------){:target="_blank"} are developed around OpenUSD\.

Therefore, this article and subsequent chapters will refer to NVIDIA‚Äôs Learning Path to introduce OpenUSD\. Different from the official Course, I will demonstrate it with Omniverse Kit\-based Application instead of simply using OpenUSD‚Äôs API, because as mentioned above, Omniverse Kit\-based Application It is just one of the OpenUSD solutions\. In other words, there will be some similarities and differences in actual use\.


![[https://www\.nvidia\.com/en\-us/training/](https://www.nvidia.com/en-us/training/){:target="_blank"}](/assets/59dee6c16bd5/1*b-1PDP12B7CyS_jbmPv_zw.png)

[https://www\.nvidia\.com/en\-us/training/](https://www.nvidia.com/en-us/training/){:target="_blank"}


[![](https://www.nvidia.com/content/dam/en-zz/Solutions/learn/learning-path/openusd/learn-openusd-og-1200x630.jpg)](https://www.nvidia.com/en-us/learn/learning-path/openusd/){:target="_blank"}


The official courses are all executed through online Jupyter\. It takes about 5 minutes to start each time\. Launch will open the entire folder for you, and you can open the notebook yourself\.


![](/assets/59dee6c16bd5/1*lcQigfOC8-p7J20LS3D8vw.png)



![](/assets/59dee6c16bd5/1*N__SLlz9RbX3Ov-v2P8O_Q.png)


There may be some minor mistakes that need to be corrected by yourself, such as missing the first parameter in the example below\.
```ini
prim = UsdGeom.Xform.Define('/ExamplePrim')
```

We should fix it like this\.
```ini
prim = UsdGeom.Xform.Define(stage, '/ExamplePrim')
```

As for the details, just follow the course step by step\.
This article mainly focuses on Omniverse, so it will not operate all the content in the course through Omniverse\. The detailed theoretical part of OpenUSD still needs to refer to the official Course\. This article only selects some important content to practice in Omniverse Kit\.

In addition, because the data of all objects cannot be controlled and viewed on the Omniverse interface, we still need to use VS Code to view the original \.usd file \( \.usda\) \. It is recommended to install the **USD Language** extension to control and view the before and after changes\.


![](/assets/59dee6c16bd5/1*djlcPTSmUA6tWlQrLhqelA.png)

### Learn OpenUSD: Learning About Stages, Prims and Attributes

In order to understand OpenUSD, we must first understand **Stages, Prims and Attributes** \. A relatively superficial understanding is how to describe an object in \.usd\. It can be Mesh, Light, etc\. This object is Prim, and multiple Prims can form a stage\. , the data in Prim is Attributes\.

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-17+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-17+V1){:target="_blank"}

In order to be able to express the results of Course in Omniverse Kit, **Omniverse USD composer** can be used here to do relevant demonstrations\. This was learned in the previous article [„ÄêOmniverse„ÄëDevelopment 101: Getting Started with Kit\-Based Development](../78f8915183be/) \. Or you can read more detail here

[**USD Composer Overview \- Omniverse USD Composer**](https://docs.omniverse.nvidia.com/composer/latest/index.html){:target="_blank"} 
[_NVIDIA Omniverse‚Ñ¢ USD Composer is an Omniverse app for world\-building that allows users to assemble, light, simulate‚Ä¶_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/composer/latest/index.html){:target="_blank"}

First, use VS code to create a file named _MyModel\.usda_ \.
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

What should be noted is that it is best to name it \.usda instead of \.usd, because USDA\(scii\) is for humans to read\. In addition, there have others file formats, like USDC \(compressed\) and USDZ \(ipped\) \.
If successful, you can see the structure of the _MyModel\.usda_ file in the Layer in the upper right corner\.


![](/assets/59dee6c16bd5/1*W1nDlI-N6raSxITzb4IgFQ.png)


If you switch to Stage, you will find a similar structure\.


![](/assets/59dee6c16bd5/1*rpFzm8WuJQWkxuN20MzIaA.png)


From this example, we can‚Äôt tell the difference between Stage and Layer\. We might as well add another \.usda, but this time we use the new functions of the App and go to new from the file in the upper left corner\.


![](/assets/59dee6c16bd5/1*tZSxHkU6CuJnm9WDKYbmDQ.png)


The default Layer includes floor and lighting\. At this time, when we switch Layer and Stage, we can still find that they are the same too\.


![](/assets/59dee6c16bd5/1*onwDkCKpFfWayyfq68DvWA.png)


At this time, select **Insert Sublayer** in Layer and select _MyModel\.usda_ \. You can find that there is an additional _MyModel\.usda_ in Root Layer\. In fact, you can completely regard **a \.usd file as a layer** , but the layer may not necessarily as a \.usd because we have not yet saved the new root layer as \.usda\.


![](/assets/59dee6c16bd5/1*UrTAmkqG-bDB13fKkNNjzA.png)



![](/assets/59dee6c16bd5/1*_TPlNXom0-ijkJCpdbmLrw.png)


But in most cases, \.usd is almost the same as layer, except that "layer" has an upper\-lower hierarchy semantically\. We might as well save this Root layer as Layout\.usda first, and open it\. It should look like this\.
```python
#usda 1.0
(
    customLayerData = {
        # ...
    }
    defaultPrim = "World"

    subLayers = [
        @./MyModel.usda@
    ]
)

def Xform "World"
{
}

def Xform "Environment"
{
    # ...

    def DomeLight "Sky" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        # ...
    }

    def DistantLight "DistantLight" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        # ...
    }

    def Scope "Looks"
    {
        def Material "Grid"
        {
            # ...
            def Shader "Shader"
            {
                # ...
            }
        }
    }

    def Mesh "ground" (
        prepend apiSchemas = ["MaterialBindingAPI"]
    )
    {
        # ...
    }

    def Plane "groundCollider" (
        prepend apiSchemas = ["PhysicsCollisionAPI"]
    )
    {
        # ...
    }
}
```

In this way, due to space constraints, I will omit a large number of attributes and leave only the important parts\. 
Basically the content is the same as what we see in Layer in USD Composer\. What can be noted is that
```ini
subLayers = [
        @./MyModel.usda@
    ]
```

This line indicates that _MyModel\.usda_ is a sublayer of _Layout\.usda_ \. So what does it do? We can open Stage and see


![](/assets/59dee6c16bd5/1*NPnwvpaPJN6XhkC5xj7flg.png)


You can see that _Layout\.usda_ contains the contents of _MyModel\.usda_ \. What‚Äôs more interesting is that if we change _MyModel\.usda_ to this
```python
#usda 1.0

def Xform "World"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

We changed _Scope ‚ÄúGeometry‚Äù_ to _Xform ‚ÄúWorld‚Äù_ \. Intuitively, we can imagine that two _‚ÄúWorld‚Äù_ will appear in the Stage, but the Stage shows that the _"World‚Äù_ of the two Layers are merged\. As a result, only one _‚ÄúWorld‚Äù_ is in the Stage\.

We can try to add a Cube in _Layout\.usda_ , which is the current Root Layer


![](/assets/59dee6c16bd5/1*VvjNFyHTl6WON56kIYLeSw.png)



![](/assets/59dee6c16bd5/1*9TQZNZ1te1zC4vC-4EXRXg.png)


After saving, observe the changes in Layout\.usda\. You can find that world has content like this
```python
def Xform "World"
{
    def Mesh "Cube"
    {
        float3[] extent = [(-50, -50, -50), (50, 50, 50)]
        int[] faceVertexCounts = [4, 4, 4, 4, 4, 4]
        int[] faceVertexIndices = [0, 1, 3, 2, 4, 6, 7, 5, 6, 2, 3, 7, 4, 5, 1, 0, 4, 0, 2, 6, 5, 7, 3, 1]
        normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0)] (
            interpolation = "faceVarying"
        )
        point3f[] points = [(-50, -50, 50), (50, -50, 50), (-50, 50, 50), (50, 50, 50), (-50, -50, -50), (50, -50, -50), (-50, 50, -50), (50, 50, -50)]
        texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0), (0, 1), (0, 0), (1, 0), (1, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0)] (
            interpolation = "faceVarying"
        )
        uniform token subdivisionScheme = "none"
        double3 xformOp:rotateXYZ = (0, 0, 0)
        double3 xformOp:scale = (1, 1, 1)
        double3 xformOp:translate = (55.72931671142578, 0.000008976281606010161, -60.18137741088867)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
    }
}
```

Some values ‚Äã‚Äãmay be different, but you can notice that, first, _‚ÄúWorld‚Äù_ in _Layout\.usda_ does not contain _"Box"_ , because _‚ÄúBox‚Äù_ is defined in _MyModel\.usda_ , and _Layout\.usda_ finds _‚ÄúBox‚Äù_ through subLayers\. 
Second, because our current Authoring Layer is _Layout\.usda_ , all changes will be in Layout\.usda, so the new _‚ÄúCube‚Äù_ will be in _Layout\.usda_ \.

One thing worth noting is that the type \(Scheme\) of the new Cube object \(Prim\) in Omniverse is Mesh, and you need to define eight vertices yourself\. OpenUSD‚Äôs Course directly uses the Cube Scheme\.

In short, the difference between **Stage** and **Layer** appears at this time\.


![](/assets/59dee6c16bd5/1*eDXSSezdd5zi_n9L1z7quA.png)



![](/assets/59dee6c16bd5/1*wPrWUDzhzIz-OEERkcNzUA.png)


In fact, **Stage is the result of merging all Layers** \. If we use digital painting as an analogy, such as Photoshop or Procreate, Layer just like a layer, and Stage is the resulting picture on the screen\. You can imagine that if all After the Layer is flattened into one layer, it is the Stage\.

In other words, Stage is a bit like the concept of Scene in Blender\. There are mesh, light, material and other objects in Scene\. These objects in Stage are collectively called **Prim** \. The types include World, Cube, Box, Light, etc\., all of which are prim\. Different The type will be called **Scheme** , where the Scheme of the Prim _‚ÄúWorld‚Äù_ is **Xform** \(Transformation\), the Scheme of _‚ÄúCube‚Äù_ is **Mesh** , and the Scheme of _‚ÄúBox‚Äù_ is **Cube** \.

At this point, we can further inspect the two Worlds in the Layer and find that their prim paths are exactly the same\.


![](/assets/59dee6c16bd5/1*yFzk50WVLnRCe9qtp4zGww.png)



![](/assets/59dee6c16bd5/1*Kdh3qjkMI551Y5-ewD6w5A.png)


Therefore, when they are composed into a single Stage, they will be regarded as the same Prim, just like they are at the same position in the two layers in Photoshop\. After the flattening and merging, the upper layer will cover the lower layer\. Content in the same position will be mixed\.

Similarly, Stage has similar logic\. The two _‚Äúworlds‚Äù_ will compose\. The conflicting parts will be given priority by the upper layer, that is, _Layout\.usda_ is the main one, but the non\-conflicting parts will exist at the same time\. , which will produce the results seen in Stage\.
This relationship is indeed like a Layer, so in Omniverse, or in the OpenUSD Application, each \.usd will be imported into the App and converted into a layer\. The currently opened \.usd Layer is called Root Layer\. There will also be a Sub\-layer under it, and **App will be dynamically composed into a stage** \.


![](/assets/59dee6c16bd5/0*RkAzYlivlc6Jt3SY)



[![](https://miro.medium.com/v2/da:true/resize:fit:1200/0*MfX_Sm2AVS_RGUB1)](https://medium.com/@nvidiaomniverse/what-you-need-to-know-about-universal-scene-description-from-one-of-its-founding-developers-12625e99389a){:target="_blank"}


Therefore, the concept of Stage will be more complicated than Scene\. It is officially called **Scenegraph** because Stage is the result of dynamic computing of multiple layer compositions, that is, the result of the merger of multiple \.usd\. As long as the Prim in a certain Layer has If it changes, a Stage will be recalculated\. The connection between Prim and Prim, and the connection between files and files form a **Graph** \.
Compared with **dynamic Stage** , **static Scene** is also the result of merging multiple files, but all link relationships will be discarded\. Therefore, even if other files change, it will not affect the Scene\. If you want to generate a Scene, you must Re\-export and Re\-import all changes\.

Let me make an analogy from another perspective\. A static Scene is like digital painting without using the layer function\. All changes are on the same layer, so all changes will overwrite past changes\. A dynamic Scene is like every Individual effects are placed on different layers, but the results of the blend of all layers are displayed on the screen\.


![[https://www\.youtube\.com/watch?v=SaBXE4yQetk](https://www.youtube.com/watch?v=SaBXE4yQetk){:target="_blank"}](/assets/59dee6c16bd5/1*yMi85V5xbd8Qlk-NhyRwlQ.png)

[https://www\.youtube\.com/watch?v=SaBXE4yQetk](https://www.youtube.com/watch?v=SaBXE4yQetk){:target="_blank"}

From the perspective of program development, a static Scene is like simply using zip for version control\. The source code is completely saved every time, but it is difficult to trace where each prim comes from, and it will also be saved\. 
A common situation for a large number of duplicate and expired prims is version control such as _final\.zip, final\_final\.zip, and final\_final\_final\.zip_ \.

A dynamic Stage is like using Git for version control\. Changes to each file will be committed and merged\. Each person in charge can work independently, and the same functions are only stored in the corresponding single file\. For example, _Layout\.usda_ only stores the Sub\-layer relationship of _MyModel\.usda_ , but the details of _‚ÄúBox‚Äù_ are stored in another file\. In this way, although _Layout\.usda_ uses _‚ÄúBox‚Äù_ , it does not need to store all the details of _‚ÄúBox‚Äù_ , only the link relationship needs to be stored, which can also avoid problems like **Duplicate code** \.


![[https://zhiminzhan\.medium\.com/10\-minutes\-guide\-to\-git\-version\-control\-for\-testers\-f58e059bb5e7](https://zhiminzhan.medium.com/10-minutes-guide-to-git-version-control-for-testers-f58e059bb5e7){:target="_blank"}](/assets/59dee6c16bd5/0*x0QyIs5qFv9VSh9B.png)

[https://zhiminzhan\.medium\.com/10\-minutes\-guide\-to\-git\-version\-control\-for\-testers\-f58e059bb5e7](https://zhiminzhan.medium.com/10-minutes-guide-to-git-version-control-for-testers-f58e059bb5e7){:target="_blank"}

At this time, the **Repository** is similar to all Layers, including all \.usd, and the **Stage** is like the pulled **working folder** , which is the parsed data and files\.

The advantage of a static Scene is that all Prims will be stored in one file and can be clearly seen at a glance\. All changes are in the same file\. There is no need to store additional relationships and only need to be parsed once \(if no changes have occurred\) \. On the contrary, a dynamic Stage will It takes more space to store the link relationships of files, and it also takes more time to repeatedly calculate the results, but the advantage is that all Prims will only exist in one place and one file at the same time, and each file can be modified **independently** \.
In other words, if there is no link between files, there is no need for dynamic compose\. A static Stage can be said to be a **Scene** , but because Scene and Scene are dynamically merged using Layer, each object in it, that is, Prims are connected to each other to form a **Graph** , so Stage is also called **Scenegraph** \.


![[https://cganimator\.com/usd\-in\-3dsmax\-1\-export/](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}](/assets/59dee6c16bd5/0*Md_CQfLydwhUTURe.jpg)

[https://cganimator\.com/usd\-in\-3dsmax\-1\-export/](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}

In addition, Stage is not just a simple collection of all Prims together\. The Root layer can still change all Prims, but these changes will not really change the Prims in the Sub\-layer, that is, the original Prims will still be saved\. When parsing the Stage, the Prim of the Root layer will overlay the Prim of the Sub\-layer \(if there is a conflict\) \.


> Enables non\-destructive editing, layering, and referencing 





Therefore, this feature is called **non\-destructive editing** \. In contrast, if the Scene is modified using the traditional method, because all prims are integrated into a single file, all changes will be in this single file\. , so as long as the prim is changed, the original prim will not be retained\. 
At the same time, because we theoretically no longer know where this prim comes from, it will cause **irreversible destructive editing** \.

In other words, the advantage of Stage is that the **upstream and downstream relationships** of all changes are clear and independent of each other\. The upstream is like the Sub\-layer, and the downstream is the Root layer\. Upstream means that the Sub\-layer is closer to the data of the early stage in the process\. These The data belongs to the lower layer, and the downstream data is the data at a later stage in the process\.


> OpenUSD Stage is the key to managing and interacting with 3D scenes 





In summary, Stage is not simply a scene, but the key to managing multiple scenes, because we can imagine exhausting each sublayer to the bottom layer\. They are actually one scene because they have no connection relationship\. Each scene It can be stored in \.usd, and can also become a sub\-layer and be linked to other layers, so what is emphasized here is


> \.USD storing and exchanging 3D scene data \(mesh, camera, light, shader\) 





In fact, Blender‚Äôs Scene format \.blend has similar functions\. For example, \.blend can link and append other \.blends\. However, it is not as modular as Omniverse, or OpenUSD is so thorough that all objects and data are Can be packaged as Prim\.

In other words, the importance of **Modularity** and **Scalability** in the 3D field is not only emphasized now\. The main reason is that with the advancement of CG, projects have become more and more complex to show better and better result, which also leads to the need for more The participation of multiple people increases the importance of independent work\.


> Ideal for complex projects involving multiple collaborators 





Therefore, the advantage of OpenUSD is that any changes are **superimposed upwards** , that is, experts in various fields will be responsible for individual Layers, and later changes will be based on earlier changes\. For example, the overall style adjustment of the images will be in the scene\. On top of the layout, just like in the previous digital painting example, the filter layer should be on top of the line drawing layer\.

From a coding point of view, Modularity is similar to **decoupling** , and Scalability is like the **Open\-Closed Principle** in the SOLID principle\. All subsequent changes are expansions and will not modify the original code\. These are all changes as the project evolves\. The more complex, the lower the modification cost\.

In the same way, the purpose of OpenUSD is to reduce the cost of modifying the CG process, because as long as the traditional process is modified, it requires a large number of repeated use of different DCC \(Digital Content Creation\) export, import various file formats, such costs It will increase exponentially with the scale, because as long as there is a change in one of the points, it is possible to restart the entire process\.
What‚Äôs worse, there are new changes when restarting the process, which will lead to catastrophic version control and scene consistency\. , OpenUSD wants to solve this problem, and Omniverse is a DCC based on \.usd proposed by NVIDIA\.

[**Products Using USD ‚Äî Universal Scene Description 24\.08 documentation**](https://openusd.org/release/usd_products.html#blender-foundation){:target="_blank"} 
[_USD has support in many 3D Content Creation Applications and Ecosystems\. This list is maintained by the community, and‚Ä¶_ openusd\.org](https://openusd.org/release/usd_products.html#blender-foundation){:target="_blank"}

Next, let‚Äôs talk formally and in\-depth about the important component of Stage, **Prim**


> Used to build and manage 3D scenes\. Facilitate data encapsulation and sharing\. 





Prim is the basic unit in Layer\. Any **imaginable** Mesh, Xform or **imaginable** material, shader, animation can be a Prim\. Let‚Äôs take the original _MyModel\.usda_ as an example\.
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

This Layer corresponds to three types of Prim, **Scope, Xform, and Cube** in Stage\. From a coding perspective, it like class\. Three prims are declared here\. The variable names are **_‚ÄúGeometry‚Äù,_ _‚ÄúGroupTransform‚Äù_ , and _‚ÄúBox‚Äù_** , but in fact the complete variable names are We will call it Prim Path\. We can open _MyModel\.usda_ in Omniverse and see from the Properties in it


![](/assets/59dee6c16bd5/1*VUK4R8nFC76anZYwvHFsCw.png)



![](/assets/59dee6c16bd5/1*7kuavv0dxfgtT9Zoro8C_w.png)



![](/assets/59dee6c16bd5/1*yH5n3Tzhm7jr-wZLFLtOlA.png)


In this way, you can understand why Prims from different layers but with the same name will be merged, because their complete variable names are the same, but if the complete Prim paths are different, they will exist separately in the Stage\.
Then you need to explain Prim‚Äôs Property, select _‚ÄúBox‚Äù_ , then click **Add Transformation** in the Property, and save the file\.


![](/assets/59dee6c16bd5/1*ppimN93aDGq3LL1VYT06DA.png)



![](/assets/59dee6c16bd5/1*mb-yKz2lSzFRalmGcDHB7g.png)


You can find that _MyModel\.usda_ becomes as follows\. You can find that Omniverse has added a lot of data\. The upper part of the file belongs to the Custom Layer data that Omniverse needs\. That is, the file needs custom data when it is used as a layer\. We will omit the jump in this part first\. Pass\.
```python
#usda 1.0
(
    customLayerData = {
        # ...
    }
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double3 xformOp:rotateXYZ = (0, 0, 0)
            double3 xformOp:scale = (1, 1, 1)
            double3 xformOp:translate = (0, 0, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
        }
    }
}
```

What we want to pay attention to is the changes in _‚ÄúBox‚Äù_ \. There are four more lines, which are the three common Transformations and the order of operate\. There are two things here\.
First, the reason why Transformation is placed in the Property tab in the interface is precisely because Transformation is indeed a type of Property\. To be more precise, the content of Prim is the content in **def** \. For example, these four lines all belong to Property\.
```python
double3 xformOp:rotateXYZ = (0, 0, 0)
double3 xformOp:scale = (1, 1, 1)
double3 xformOp:translate = (0, 0, 0)
uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
```

Second, Transform does not necessarily exist in a Prim such as **Cube** \.
But there are usually some common rules\. For example, different types of Prim in Omniverse will have some preset fields\. The more obvious one is **Scope** , because it is the most lightweight Prim and does not have any actual geometry or settings\. The main function is to integrate different Prims into different Scopes, which is somewhat similar to the function of a folder\. The official word Container is used to describe the concept that a Scope is equipped with different Prims\. 
Therefore, there is no **Add Transformation** in the Property field of Scope in Omniverse\. You can even think of Scope as an Xform but it cannot be transformed\. In other words, Scope is just to establish the existence of hierarchy and is a Prim that creates the most lightweight parent\-child hierarchy\.

In fact, if you refer to the official website of OpenUSD, you can find that Property is divided into two categories, namely Attribute and Relationship\.


![[https://openusd\.org/release/api/class\_usd\_property\.html](https://openusd.org/release/api/class_usd_property.html){:target="_blank"}](/assets/59dee6c16bd5/0*QyiSyZN-ba1HLSVL.png)

[https://openusd\.org/release/api/class\_usd\_property\.html](https://openusd.org/release/api/class_usd_property.html){:target="_blank"}

Basically, most of the data in Prim is Attribute\. Basically, a name and value are an Attribute, and relationship is a path where the value is stored\. It is often used in Material\. You can download one through the Material Tab under Omniverse\. material, then select the Material in the Box and save it\.


![](/assets/59dee6c16bd5/1*rPqoah0UmPDNgzMedxOCIA.png)


Afterwards, we can observe the changes in _MyModel\.usda_ \. Similarly, we omit changes other than _‚ÄúBox‚Äù_ , and the extra part is relationship\.
```python
rel material:binding = </World/Looks/Carbon_Fiber_ANI_01> (
                bindMaterialAs = "weakerThanDescendants"
            )
```

It is also worth mentioning that **Primvars** is a type of Attribute\. Its full name is Primitive Variable\. You can find it in the Property\. You can think of it as the data carried on each Vertex, or it can be extended to the data carried on each Face\. The data is mainly used by Shader\. It can be imagined that these data will be packaged into VBO later and then given to Shader for rendering\.

The point is, Prim contains many Properties\. More generally speaking, Prim can **encapsulate** a bunch of related data\. Therefore, Mesh, Light, etc\. can be represented by Prim, because Prim can put in various customized data at parameters\.


> A core component that acts as a container for data and attributes in a scene\. 




### Conclusion

This article briefly introduces some simple interface interactions in Omniverse Kit, and the interaction with \.usd files, as well as some basic terminology explanations\. You can find that Omniverse Kit is, to a certain extent, just a graphic used to modify \.usd interface, so I wrote at the beginning that **instead of saying that Omniverse is a software that can import and export \.usd files, it is better to say that Omniverse is a software based on OpenUSD\.**

Even NVIDIA has a series of activities at this year‚Äôs SIGGRAPH 2024 and SIGGRAPH Asia 2024 to promote OpenUSD instead of Omniverse\. The reason that is easier to understand is that they also hope that other DCCs can join in supporting the input and output of \.usd files, even Synchronization, so that all digital assets can be transmitted without barriers\. In other words, OpenUSD is not exclusive to Omniverse\. To be more precise, Omniverse Kit only supports one of the applications of OpenUSD, and is just one of the OpenUSD solutions provided by NVIDIA to everyone\.


[![What is the USD File Type? | Getting Started in NVIDIA Omniverse](/assets/59dee6c16bd5/4aab_hqdefault.jpg "What is the USD File Type? | Getting Started in NVIDIA Omniverse")](https://www.youtube.com/watch?v=GOdyx-oSs2M){:target="_blank"}


After understanding the relationship between Omniverse and OpenUSD, we will continue to explore the Omniverse Kit with reference to the Learning Path\.


[![](https://forums.leadtek.com/images/Leadtek_AI-Forum.jpg)](https://forums.leadtek.com/tw/post/3387){:target="_blank"}


[**OpenUSD ÂòøÊ∫ú**](https://www.zhihu.com/column/c_1689606249291915265){:target="_blank"} 
[_NVIDIA„ÄÅÁó™ÁßëÂùèÊûêÁÉõÁöÑOpenUSDÊ†ºÂºèÊòØÂòÅÁäØ_ www\.zhihu\.com](https://www.zhihu.com/column/c_1689606249291915265){:target="_blank"}

[**USD in 3dsMax \#1 ‚Äî Export**](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"} 
[_USD for 3dsMAx 0\.5 has been released\. You can see how it has progressed in the What‚Äôs new section of the official‚Ä¶_ cganimator\.com](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}


[![](https://static.wixstatic.com/media/b46d06_64a0f861ad0744fea6c47de8e459ed41~mv2.png/v1/fill/w_682,h_511,al_c,lg_1,q_85/b46d06_64a0f861ad0744fea6c47de8e459ed41~mv2.png)](https://www.ireneortegasanz.com/post/master-the-usd-system-the-keys-to-use-it-in-the-layout-department){:target="_blank"}


[**Layers ‚Äî Omniverse Extensions**](https://docs.omniverse.nvidia.com/extensions/latest/ext_core/ext_layers.html){:target="_blank"} 
[_The Layers Extension provides a convenient way to organize and manage your scene while also providing a comprehensive‚Ä¶_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/extensions/latest/ext_core/ext_layers.html){:target="_blank"}

[**Overview ‚Äî Omniverse Kit 1\.8\.1 documentation**](https://docs.omniverse.nvidia.com/kit/docs/omni.kit.widget.layers/latest/Overview.html){:target="_blank"} 
[_Edit description_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/kit/docs/omni.kit.widget.layers/latest/Overview.html){:target="_blank"}

[**Usd Survival Guide**](https://lucascheller.github.io/VFX-UsdSurvivalGuide/pages/core/elements/property.html#relationshipOverview){:target="_blank"} 
[_This repository holds the docs and examples for the Usd Survival Guide\._ lucascheller\.github\.io](https://lucascheller.github.io/VFX-UsdSurvivalGuide/pages/core/elements/property.html#relationshipOverview){:target="_blank"}


[![](https://aousd.org/wp-content/uploads/sites/28/2023/10/nv-AOUSD-Schematic-blog-social-blog-1280x720-16x9-1-2.png)](https://aousd.org/blog/explainer-series-what-is-openusd/){:target="_blank"}


[**Composition Details Panel ‚Äî Omniverse USD**](https://docs.omniverse.nvidia.com/usd/latest/usdview/panel_composition.html){:target="_blank"} 
[_The Value tab shows the value of the selected property\. The property selection comes from the Properties Panel ‚Ä¶_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/usd/latest/usdview/panel_composition.html){:target="_blank"}

[**Content Reuse ‚Äî Omniverse USD**](https://docs-prod.omniverse.nvidia.com/usd/latest/learn-openusd/independent/modularity-guide/content-reuse.html){:target="_blank"} 
[_The concepts of reuse and instancing are very closely related\. Understanding reuse and modularity is a important before‚Ä¶_ docs\-prod\.omniverse\.nvidia\.com](https://docs-prod.omniverse.nvidia.com/usd/latest/learn-openusd/independent/modularity-guide/content-reuse.html){:target="_blank"}

Thank you for reading\! If you found my article helpful or have any feedback, feel free to reply\. If you‚Äôd like to support me, you can:
- Clap üëè or share your thoughts üí¨
- [Follow me on Medium](https://medium.com/@maochinn){:target="_blank"}
- [Subscribe to me on Medium](https://medium.com/maochinn){:target="_blank"}
- [Connect with me on LinkedIn](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


You can also check out my other series of articles:
- [„ÄêOmniverse„ÄëDevelopment 101: Getting Started with Kit\-Based Development](../78f8915183be/)
- [„ÄêOmniverse„ÄëDevelopment 101: Understanding Applications and Extensions](../1d990d98b7f9/)
- [„ÄêOmniverse„ÄëDevelopment 101: Kit Workshop SIGGRAPH 2022](../310a189add0b/)



_[Post](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
