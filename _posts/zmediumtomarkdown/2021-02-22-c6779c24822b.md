---
title: "【Paper】Motion Path Editing"
author: "帽捲"
date: 2021-02-22T11:38:17.576+0000
last_modified_at: 2021-09-21T07:30:29.274+0000
categories: ["Maochinn"]
tags: ["computer-graphics","motion-graphics"]
description: "先寫一些我要記錄的東西好了，一天到晚挖坑都不填的"
image:
  path: /assets/c6779c24822b/0*QkLhjNiiUKZCs7hs.png
render_with_liquid: false
---

### 【Paper】Motion Path Editing

先寫一些我要記錄的東西好了，一天到晚挖坑都不填的


![Editing the path of a walking motion\. The left image shows the original motion, the right shows the edited result\.](/assets/c6779c24822b/0*QkLhjNiiUKZCs7hs.png)

Editing the path of a walking motion\. The left image shows the original motion, the right shows the edited result\.

簡單來說就是我們輸入一段動畫，然後可以計算出這一段動畫的path，也就是上圖看到的線，然後我們可以透過調整這條線來做成其他動畫。那為甚麼要這麼做呢?因為如果每一段動畫都需要人工捕捉，你可以想像這是相當大的工作量，那為甚麼能這麼做，如果有做過3D遊戲應該會知道，人物的動作跟移動是分開的，所以我們可以把動畫拆出path當作移動，然後在拿原始動畫\-path就可以得到動作。


![A character zig\-zags relative to its path\(left\) \.If the details of the motion are represented in an absolute sense \(e\.g\. left and right on the page\),they may not apply if the direction of travel is changed\(center\) \.](/assets/c6779c24822b/0*EE9gZ2C0f1caRUjp.png)

A character zig\-zags relative to its path\(left\) \.If the details of the motion are represented in an absolute sense \(e\.g\. left and right on the page\),they may not apply if the direction of travel is changed\(center\) \.

這個應該會比較清楚，如果從數值上理解的話，你可以理解成我們拆出高頻以及低頻的訊號，我們會傾向右邊的結果而不是中間的，因為我們知道高頻的資訊應該是在path的local space之下，其實這種方式在mesh的編輯也是一樣的，我們會把表面的起伏\(高頻\)記錄下來，只對laplasian的mesh\(低頻\)操作，等變形完再加回去。
### Fit Curve

總之，這邊會遇到一個問題，我要怎麼算出這條path?一種直覺的方式就是線性回歸，我們想辦法找出能夠fit原始動畫的曲線。


[![](https://opengraph.githubassets.com/2edb9a9cd6d8280576787cafef194f35a272806c1d41ff03c7b6cbeebd314a5d/soswow/fit-curve)](https://github.com/soswow/fit-curve){:target="_blank"}


但這邊要注意，我們要取出低頻訊號，所以我們不應該overfitting，所以我們可以使用Cubic B\-spline Curve，當然也可以使用Bezier Curve，但這邊要注意一點，我們fit完的Curve應該要能夠很簡單的編輯。有關於Cubic B\-spline Curve可以參考


[![](https://miro.medium.com/v2/resize:fit:797/1*NfB4LkjQ0PMYQhzuWsid-g.png)](https://medium.com/maochinn/fltk-project-roller-coasters-f488c70dd7e9){:target="_blank"}


總之，我們要想辦法用4個控制點來fit，由於只是三次式，所以自然沒有辦法fit到很接近，但這也是我們刻意為之的\(只要低頻訊號\)。

開始解以前，我們可以先來複習一下2D的linear regrssion。


![](/assets/c6779c24822b/0*QFWLhgHuXeuG-zpl)



![](/assets/c6779c24822b/0*y8XzpX06TB4Sq6GN)


那回到我們的path，我們所求變成三個參數P0~P3，也就是對應到4個控制點。


![](/assets/c6779c24822b/0*BaahLm8HEOoKO8-j)



![](/assets/c6779c24822b/0*myii7eJxScgFWvLn)



![](/assets/c6779c24822b/0*cNUkMUEOM88h9NxE)



![](/assets/c6779c24822b/0*vrHsD9b-KImu1W-X)


這邊可以注意到，最後我們解的是4\*4的系統，所以解起來相當簡單，這也就是因為我們用的是cubic的curve。

這邊可以看我在blender裡面寫的code。
```py
# return 
# c_points:     list[Vector], control points
# t:            parameter list
# parameter
# initial_curve:list[Vector]
def solveCubicBspline(initial_curve):
    # if initial_curve_ob.type == 'CURVE':
    #     init_curve = initial_curve_ob.data

    # # points of initial path is data point 
    # Q = []
    # for point in init_curve.splines[0].points.values():
    #     Q.append(point.co.xyz)

    Q = []
    for point in initial_curve:
        Q.append(point.co.xyz)

    # have n point, 0 <= i <= n-1
    n = len(Q)

    # use cubic b-spline to fit
    def B3_0(t):
        return 0.16667 * (1-t) * (1-t) * (1-t)
    def B3_1(t):
        return 0.16667 * (3*t*t*t - 6*t*t + 4)
    def B3_2(t):
        return 0.16667 * (-3*t*t*t + 3*t*t + 3*t + 1)
    def B3_3(t):
        return 0.16667 * t*t*t
    
    t = computeChordLengthParameter(Q)

    # use least square
    # solve Ax = b
    A = Matrix(([0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0]))
    # 4 control point 
    p = [Vector(), Vector(), Vector(), Vector()]

    # A
    for i in range(0, n):
        B0 = B3_0(t[i])
        B1 = B3_1(t[i])
        B2 = B3_2(t[i])
        B3 = B3_3(t[i])

        A[0][0] +=  B0 * B0
        A[0][1] +=  B0 * B1
        A[0][2] +=  B0 * B2
        A[0][3] +=  B0 * B3

        A[1][1] +=  B1 * B1
        A[1][2] +=  B1 * B2
        A[1][3] +=  B1 * B3

        A[2][2] +=  B2 * B2
        A[2][3] +=  B2 * B3

        A[3][3] +=  B3 * B3

    A[1][0] = A[0][1]

    A[2][0] = A[0][2]
    A[2][1] = A[1][2]

    A[3][0] = A[0][3]
    A[3][1] = A[1][3]
    A[3][2] = A[2][3]

    # dimension mean is x, y, z
    for dimension in range(0, 2):
        b = Vector([0, 0, 0, 0])
        for i in range(0, n):
            b[0] += B3_0(t[i]) * Q[i][dimension]
            b[1] += B3_1(t[i]) * Q[i][dimension]
            b[2] += B3_2(t[i]) * Q[i][dimension]
            b[3] += B3_3(t[i]) * Q[i][dimension]

        x = Vector()

        # solve Ax = b
        # x = inverse(A)b
        x = A.inverted() @ b

        p[0][dimension] = x[0]
        p[1][dimension] = x[1]
        p[2][dimension] = x[2]
        p[3][dimension] = x[3]
    
    p[0][2] = 0
    p[1][2] = 0
    p[2][2] = 0
    p[3][2] = 0

    return p, t

def computeChordLengthParameter(Q):
    # have n point, 0 <= i <= n-1
    n = len(Q)
    # computer distance of curve
    d = 0
    for i in range(1, n):
        d += (Q[i] - Q[i-1]).length

    # define t[i] with chord-length
    # t[0] = 0, t[n-1] = 1
    t = [0.0,]
    for i in range(1, n):
        t.append(t[i-1] + (Q[i] - Q[i-1]).length/d)
    t[n-1] = 1.0

    return t
```


待續…

這是我自己的簡單實作在blender上，但這個實作還包含registration curve，這個有空在開一篇來講吧。


[![](https://opengraph.githubassets.com/7c16592d646c2c493b6af3a4368707bd54cfa02346954a7cffac2d7f9a3f48d4/maochinn/motion_path_editing)](https://github.com/maochinn/motion_path_editing){:target="_blank"}



[![Motion Path Editing with Registration Curve(Transition)](/assets/c6779c24822b/5ff6_hqdefault.jpg "Motion Path Editing with Registration Curve(Transition)")](https://www.youtube.com/watch?v=CTjXxdkreSc){:target="_blank"}



[![Motion Path Editing with Registration Curve(Interpolation)](/assets/c6779c24822b/52c2_hqdefault.jpg "Motion Path Editing with Registration Curve(Interpolation)")](https://www.youtube.com/watch?v=ht0ixcRgAPs){:target="_blank"}




_[Post](https://medium.com/maochinn/paper-motion-path-editing-c6779c24822b){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
