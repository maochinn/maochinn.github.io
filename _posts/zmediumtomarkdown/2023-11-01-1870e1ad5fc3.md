---
title: "【Blender】Geometry Node 像素風"
author: "帽捲"
date: 2023-11-01T13:53:06.123+0000
last_modified_at: 2023-11-01T13:53:06.123+0000
categories: ["Maochinn"]
tags: ["blender","geometry-node"]
description: "這篇要介紹怎麼用Geometry Node做出像素風的圖片"
image:
  path: /assets/1870e1ad5fc3/1*4meaNyVGeCfTCfdE-RjQyg.png
render_with_liquid: false
---

### 【Blender】Geometry Node 像素風

先看結果，這篇要介紹怎麼用Geometry Node做出像素風的圖片


![](/assets/1870e1ad5fc3/1*4meaNyVGeCfTCfdE-RjQyg.png)


事實上，這種效果不需要特別使用Geometry Node也可以完成，但是最近在學Geometry Node，就拿來實驗看看。

首先先介紹一下初始設置，Blender 3\.4，基本上就是上方Geometry Nodes的layout，方塊也是預設的cube。


![](/assets/1870e1ad5fc3/1*P9GiBweKhaQFqLDUTJapCA.png)


因為主要是用Geometry Nodes，所以大部分的操作會集中在左下角的Geometry Node Editor。


![](/assets/1870e1ad5fc3/1*aFQKcyNIgrCvYDVy4k1XVw.png)


預設的Geometry Node長這樣，非常好理解


![](/assets/1870e1ad5fc3/1*2GRH0dAmIPP9Wd4UhC1Q9w.png)


但是Geometry是什麼呢？我們可以透過左上角的Spreadsheet可以看到一些端倪，畫面中的Cube中含有一個Geometry，而一個Geometry其實就表示所有3D空間上的\(幾何\)資訊，例如：一個Cube由8個Vertex、12條Edge、6個Face所構成，其中，每個面又有4個點，因此有24個Face Corner，以上這些都是Cube中的Geometry所包含的資訊。


![](/assets/1870e1ad5fc3/1*GiTqCrYSSV42lRs5lQIxyw.png)


這邊你可能有個小疑問，一個cube到底是8個點還是24個點，因為本篇不會使用到Face Corner，因此只需先理解成一個Cube有8個點就好。


![](/assets/1870e1ad5fc3/1*KXnDmEB53tmFKoE4Qx7y8A.png)



![](/assets/1870e1ad5fc3/1*kcOHPU19g-hUzercSonSgA.png)


可以注意到這邊8個Vertex，它其實就是對應我們在Edit Mode中Cube的8個點。

接下來將Geometry Node拉成這個樣子


![](/assets/1870e1ad5fc3/1*4EHEGnt5BbcU1osd8CDR0A.png)


我們直接用Grid取代掉Input，它會輸入長、寬以及水平、垂直方向要產生幾個vertex，之後會產生一個網格，如果我們個別輸入Size X = 21、Size Y = 9、Vertices X=21、Vertices Y=9 會產生類似下圖這樣的一個平面，只是在Geometry Node產生的點沒辦法在Edit Mode編輯，所以你看不見這些點。


![](/assets/1870e1ad5fc3/1*6RxwpMys6dN-MqPVmWH-zQ.png)


[**Grid Node \- Blender Manual**](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/primitives/grid.html){:target="_blank"} 
[_A 2D vector representing the default X/Y coordinates of the for the primitive's shape\. This can be connected to the…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/primitives/grid.html){:target="_blank"}

可以注意到，因為用Grid取代掉Input，因此目前產生的Geometry\(Grid\)與原始的Geometry\(Cube\)無關，因此無論你在Edit Mode怎麼樣調整你的Cube都不會對Grid有影響。

為了方便調整，可以將Grid的輸入拉到Input上，如此就能透過Property Panel直接調整長寬。


![](/assets/1870e1ad5fc3/1*wguXUktRsSzUqy0dVfG82g.png)



![](/assets/1870e1ad5fc3/1*v0IGoqE7ZxLkuePnQwuOmg.png)


接下來要產生21\*9個Cube在每個Vertices的位置上，可以透過Instance on Points，將原始的Geometry\(Cube\)作為Instance，放在每個Points上，而每個Point當然就是Grid輸出的Mesh，也就是將Grid中每個21\*9個Vertices作為21\*9個Points，最後將其輸出就完成了。


![](/assets/1870e1ad5fc3/1*-azVkNduQVvGcpc5rSGCZA.png)



![](/assets/1870e1ad5fc3/1*QTt1mOO8_X9OjqELhO1KrQ.png)


白話來說，就是將Cube複製21\*9個放在個別的位置上面，其中因為每個cube的geometry都相同，所以可以稱之為instance。另外注意Spreadsheet，我們目前的輸出都是Instance，而沒有任何的Vertex之類的，其實Vertex是就是原本的Cube，因此只需儲存一份在內部即可。


![](/assets/1870e1ad5fc3/1*o3CpCirK5azZqoJdSAkx5Q.png)


這邊可以注意到總共有21\*9=189個Instance，雖然我們知道他們的Geometry是是相同的，但是每個geometry整體有各自的position, uv\_map, rotation。

接下來，為了後續方便，我們需要將所有Instance合併成一個Geometry，可以透過Realize Instances，使用後在畫面上不會有變化，但是在Spreadsheet可以發現Instance變成0，Vertex的數量變成8\*21\*9 = 1512了。


![](/assets/1870e1ad5fc3/1*r2ekq9GNiEug6nMWxg1AAw.png)



![](/assets/1870e1ad5fc3/1*myTa_3-37s7k5hAIuLVMRQ.png)


注意到uv\_map的部分，前8個vertex的uv是相同的，這是因為前8個vertex組成第一個Cube的Geometry，因此前8個uv\_map則對應上上圖第一個uv\_map，以此類推。

[**Realize Instances Node \- Blender Manual**](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/instances/realize_instances.html){:target="_blank"} 
[_The Realize Instances node makes any instances \(efficient duplicates of the same geometry\) into real geometry data…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/instances/realize_instances.html){:target="_blank"}

接下來我們要將每個uv\_map值傳到shader editor中，在Shader Editor中加入Atrribute，並且填入uv\_map，就可以得到右圖的結果，就像是低像素的uv，因為每個cube都只填入一個顏色，也就是Grid對應的uv，因此只有21\*9個色彩而已。


![](/assets/1870e1ad5fc3/1*6BGVmxha45gnCXHSszUooQ.png)



![](/assets/1870e1ad5fc3/1*UV2inss2kx3D4rCTtkYj0A.png)


接下來我們要利用這個uv去採樣texture，有兩種做法，一般的做法是在Shader Editor中加入Image texture，另一種則是在Geometry Node中採樣Texture完再將顏色輸入到Shader Editor，前者是傳統的作法，而後者的理論上效率較高。

首先在Geometry Node中增加Named Attribute、Image Texture以及Capture Attribute，在前者的Name填入uv\_map，並將其輸入到Image Texture的Vector，也就是將uv\_map的值作為採樣Texture的uv座標，最後將採樣到的貼圖輸出出去。


![](/assets/1870e1ad5fc3/1*-lFQ7LYfbvdmqBa8pOIVaw.png)



![](/assets/1870e1ad5fc3/1*yNb8K2X9eYJeAY3NPQe1WQ.png)


同時，因為我們現在輸出的Attribute是自己多加的，因此我在Property Panel中將Attribute命名成color，可以在Spreadsheet中發現Vertex多了一個Attribute叫做color。


![](/assets/1870e1ad5fc3/1*q2K_DfVc8GiaOU133HblCA.png)


另外，在Shader editor中也要增加Atrribute，並且填入color，如此就可以得到我們想要的結果，這邊因為我們圖是3508x2450，因此我將SizeX改成35，SizeY改成24，當然如果想要更高的解析度可以將SizeX改成350，SizeY改成240就可以得到最開頭的結果了。


![](/assets/1870e1ad5fc3/1*Zr3bHB4E7V75Tcnq2tI5qA.png)



![](/assets/1870e1ad5fc3/1*Jz94bS6jJWKnmofZ7jZ44w.png)


值得注意的是，Image Texture我這邊是設定Closest與Clip，而不是預設Linear與Repeat這跟Linear與Nearest的採樣有關，這個就等其他篇在討論吧。

[**Named Attribute Node — Blender Manual**](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/read/named_attribute.html){:target="_blank"} 
[_The used for the retrieved data\. Attribute Search can be used to give a basic list of possible attribute names and data…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/read/named_attribute.html){:target="_blank"}

[**Image Texture Node \- Blender Manual**](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/image.html){:target="_blank"} 
[_The image socket can be used to connect to the Group Input node\. If this is not connected the image can be opened or…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/image.html){:target="_blank"}

另外一種作法如下，利用Store Named Attribute將color附在instance上，如此就不需要透過Realize Instances，這是因為Group Output新增的Custom Atrribute不會依附在Instance上而是依附在vertex上，因此要透過Store Named Attribute Node來手動依附\(binding\)。

Group Output的屬性預設都是附在Vertex上，這是因為系統不知道你要將Custom Attribute附在Vertex、Face或是Instance之類的東西上，因此預設就是Vertex。


![](/assets/1870e1ad5fc3/1*jC6_AU8cyLtS_n484Qu_Wg.png)


可以發現Spreadsheet中每個Instance多了一個color的attribute。


![](/assets/1870e1ad5fc3/1*LM8xJFaGlX-AfJ4rQUjAJg.png)


然後在Shader Editor中記得將Attribute Node的Type改成Instancer，表示拿Instance中的color。


![](/assets/1870e1ad5fc3/1*-j4_sv27oPKv73PTcQ6MzA.png)


這種做法在instance多的時候會發現有點卡頓的情況，這是因為每一幀都重新產生一堆instance，優點是不需要花費記憶體存大量的geometry，而一開始的方法則是產生一次instance後就轉換成Geometry存在記憶體中，也就是空間換取時間，這當然就看自己的取捨了。

[**Store Named Attribute Node \- Blender Manual**](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/attribute/store_named_attribute.html){:target="_blank"} 
[_The Store Named Attribute node stores the result of a field on a geometry as an attribute with the specified name\. If…_ docs\.blender\.org](https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/attribute/store_named_attribute.html){:target="_blank"}
### **Ref**

[**Blender节点系统介绍**](https://www.zhihu.com/column/c_1467907112601358336){:target="_blank"} 
[_Blender node system_ www\.zhihu\.com](https://www.zhihu.com/column/c_1467907112601358336){:target="_blank"}

[**Blender几何节点**](https://www.zhihu.com/column/c_1470809129169776640){:target="_blank"} 
[_Blender's Geometry Nodes_ www\.zhihu\.com](https://www.zhihu.com/column/c_1470809129169776640){:target="_blank"}



_[Post](https://medium.com/maochinn/blender-geometry-node-%E5%83%8F%E7%B4%A0%E9%A2%A8-1870e1ad5fc3){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
