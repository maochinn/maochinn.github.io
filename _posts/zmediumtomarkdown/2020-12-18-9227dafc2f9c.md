---
title: "【OpenGL】Pick"
author: "帽捲"
date: 2020-12-18T10:23:03.634+0000
last_modified_at: 2020-12-18T10:24:20.185+0000
categories: ["Maochinn"]
tags: ["computer-graphics","opengl"]
description: "這個部分算是蠻常見的功能，所以單獨拉出講。"
image:
  path: /assets/9227dafc2f9c/0*i18HYKe-6FIAgVLs.png
render_with_liquid: false
---

### 【OpenGL】Pick

這個部分算是蠻常見的功能，所以單獨拉出講。

OpenGL其實本來就有實作這方面的功能，就像是在雲霄飛車的Project中的控制點就是利用這種方式。


[![](https://miro.medium.com/v2/resize:fit:797/1*NfB4LkjQ0PMYQhzuWsid-g.png)](https://medium.com/maochinn/fltk-project-roller-coasters-f488c70dd7e9){:target="_blank"}


那在現代的OpenGL則可以利用Shader來做到類似的功能，就像是水面的Project裡面interactive simulation用到的pick。


[![](https://miro.medium.com/v2/resize:fit:565/1*tQeYd05bGqJGsFWyt0fdBw.png)](https://medium.com/maochinn/fltk-project-water-surface-a811c9cfc3b){:target="_blank"}


在正式講之前我們可以先來想想看另一個方案，Raycasting，在比較一般性的應用下，常常會使用ray casting來做為偵測，我們可以在world space任意定義一個ray，然後拿這個ray去跟world的其他物件做intersection，


![](/assets/9227dafc2f9c/0*i18HYKe-6FIAgVLs.png)


例如一些射擊的遊戲，我們可以透過將物件利用AABB、OBB、Sphere之類的東西將物件包起來，並執行簡單的hit test，那對於Rendering來說，傳統的render方式就是將把個pixel都transform到world space，然後以此為起點做ray cast，所以理論上，如果我們要pick某個pixel對應到哪個物件我們也應該使用類似的方式。


![](/assets/9227dafc2f9c/0*dVbN7Vo0b-E6TsDC.jpg)


但是因為GL並不是用raycast來render圖片，而是另一個pipeline，所以換句話說，我們也就可以用GL的render方式來做pick，而不是使用ray cast，所以我們不妨先來看看GL提供的方案是怎麼做，這邊可以先到related link看看別人的文章。

直接講結論，先透過 _gluPickMatrix_ 透過設計transformation來限縮需要被render的範圍，然後我們可以 _glRenderMode\(GL\_SELECT\)_ 來切換我們render的模式到select，把能被選擇的物件render過一次，然後透過 _glLoadName_ 把之後的每個primitive給予一個Name，通常object的每個面都會用同個Name，最後透過 _glRenderMode_ \( _GL\_RENDER_ \)得到有被打到的Name。

我們可以看看在雲霄飛車中的控制點是怎麼被選擇的。


![](/assets/9227dafc2f9c/1*vP3uJCyAyMMuhPZUAteuPw.png)


首先，先取得當前的mouse位置，然後利用限縮範圍在這個pixel的5\*5範圍，也就是這5\*5範圍的東西都會被select到。


![](/assets/9227dafc2f9c/1*ufaPGt42agYr02iUYUgfHA.png)


然後按照正常的render設定，我們要那些矩陣，然後要宣告一個select buffer，他會儲存被選擇到的資訊，他有一個既定的格式。要記得切換render mode讓東西可以被render到特定的地方來記錄，不然接下來的操作會是無效的，接下來就push一個stack，然後在render每個控制點前給予一個流水號當作是Name。


![](/assets/9227dafc2f9c/1*Uz0Eh9cwAgH1TpxWAmbPLQ.png)


然後再切回原本render mode，這時會會回傳hit的數量，然後在select buffer的第3個位置開始會有被pick到的Name，因為這邊我們只需要第一個被選擇到的所以就只拿第3個值就好\(這邊有\-1是因為前面load name的時候有\+1\)。

如果回到現代GL， _gluPickMatrix_ 可以自己設計這個matrix，或是使用stencil buffer來限制render範圍，甚至我們不需要限制，直接render整張圖， _glRenderMode_ 則是切換到另一個FBO去render，而 _glLoadName_ 則是可以直接用uniform傳到shader來當作自己設定的值當作Name，最後用那個值當作fragment的color，最後透過readpixel來把該值取出來，也就是可以拿那個值去找對應的Name和物件。

讓我們來看看實作上的細節。我們的目標是pick選擇到哪個面，這個也可以延伸成選擇到哪個物件，首先我們先創建一個FBO然後attach一個texture，注意這邊我們每個pixel是只有一個R channel unsigned int，也就是每個pixel存一個Name，這邊不一定要額外建一個FBO，你可以只用一個texture attach到其他既有的FBO。


![](/assets/9227dafc2f9c/1*AyN-i7_T57mqsJ6vrwBwEg.png)


然後到了shader，我們只需要調整fragment shader，其中fragment color就是gl\_Primitive，這個數字表示現在這個fragment是這個VAO的第幾個面。


![](/assets/9227dafc2f9c/1*s5bu4YM1B5lVpz2SOt7KLA.png)


如果我們要分物件的話，那可能就需要用2個channel，並用uniform來傳入物件編號，這就要看怎麼實作。最後就是read pixel，我們可以只read一個pixel就好。


![](/assets/9227dafc2f9c/1*zgbgACnmMT_FhUlMNlUZjw.png)


那這個的延伸其實就像是水面的project，我們可以拿texture coordinate當作fragment color，甚至也可以拿world coordinate，這樣就能達到類似raycast的效果，可以得到該點pixel第一個intersection的位置\(當然要開啟depth test\)。

總結來說，不是說raycast不好，而是raycast必須對逐個面做intersection，當場景中的物件多的時候就會是很大的開銷，尤其是在CPU做的時候，但GL的pick有比較好嗎？從根本上來看，render的速度也取決於場景物件的多寡，但是我們可以在本來就需要渲染的照片額外輸出，這並不會造成太多成本，而且這都是在GPU計算。

另外的好處是好寫，不需要處理intersection的問題，而render只要照著既有的pipeline，當然，如果intersection有別人寫好的那就當我沒說，而進一步來說，這也算是用Rendering去處理問題，就像是有時候我們可能要透過複雜的計算來算某些性質，例如:area, volume, occlusion，這個時候我們只要直接做render，有時甚至會比較慢，但是好處就是所見即所得，如果需要更高精度，大不了直接增加圖片的resolution即可。
### Related Link
