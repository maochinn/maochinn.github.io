---
title: "【Unity】Multipass Rendering"
author: "帽捲"
date: 2023-09-21T13:44:34.815+0000
last_modified_at: 2023-09-21T14:10:57.596+0000
categories: ["Maochinn"]
tags: ["computer-graphics","unity"]
description: "首先，這邊要做的事情非常簡單，就是將相機畫面render到一個Texture上，然後再render到遊戲畫面(Display)上，這件事情就是Multipass Rendering，也就是render兩次(Two…"
image:
  path: /assets/7b98d6e88641/1*d9yrgYrhNNnOYEZFXWW0iw.png
render_with_liquid: false
---

### 【Unity】Multipass Rendering

首先，這邊要做的事情非常簡單，就是將相機畫面render到一個Texture上，然後再render到遊戲畫面\(Display\)上，這件事情就是Multipass Rendering，也就是render兩次\(Two Pass\)，值得注意的是這邊的Pass是圖學意義上的Pass，並非Unity中Shader的 [Pass](https://docs.unity3d.com/Manual/SL-Pass.html){:target="_blank"} ，意義不太一樣。

事實上，這種作法類似於Postprocess，許多都會透過 [RenderTexture](https://docs.unity3d.com/ScriptReference/RenderTexture.html){:target="_blank"} 加上Fragment Shader來後處理畫面，但是這邊想用更加直覺，或是更加「遊戲引擎」的方式來做。
### Setting the Scene

首先先設置一個簡單的Scene，裡面只有個平面


![](/assets/7b98d6e88641/1*d9yrgYrhNNnOYEZFXWW0iw.png)


並且增加UI，這邊是增加一個Text，因為我們想要連UI一起後處理。


![](/assets/7b98d6e88641/1*ezxt5Jx9217ulXvzh1wKmA.png)


畫面大致設置成這樣


![](/assets/7b98d6e88641/1*JwV8fucNyeSjxYLpLb4ZFQ.png)


這是我們最終期望的畫面，類似魚眼效果的畫面


![](/assets/7b98d6e88641/1*I8aWBLPUB4b0mautyvf6WQ.png)

### Render UI on the display

那麼，因為我們希望UI的部分也要能被後處理，所以這邊需要先將Canvas的Render Mode設定換成Camera，因為Overlay是等所有東西都畫完之後，最後將Canvas中的所有東西畫到遊戲畫面上。


![](/assets/7b98d6e88641/1*MzKUaGcghex5Xx8y347wNg.png)


然後Render Camera要選擇Main Camera，也就是會將UI畫在Main Camera的Render完的畫面上。


![](/assets/7b98d6e88641/1*sYFd9iIciKPF4n7LQqAsgQ.png)



![](/assets/7b98d6e88641/1*o1wo_0QO-g7OGjfYVA_1Xg.png)


這時候可以先把解析度固定下來比較好解釋，這邊我設成1920x1080


![](/assets/7b98d6e88641/1*v0gromZV9T6dHiqyid2oVA.png)

### Render to Texture

接下來要將畫面上的內容不直接畫到遊戲畫面\(Display 1\)上，而是畫到一張Texture，這種Texture叫做 [Render Texture](https://docs.unity3d.com/Manual/class-RenderTexture.html){:target="_blank"} ，在Asset中上新增\(asset/create/render texture\)。

新增出來可以看到是一張全黑的Texture，這是因為目前沒有任何東西畫到它上面。


![](/assets/7b98d6e88641/1*6dG3mGzwOR6siuVKzkzsNQ.png)


也就是說，我們要將Main Camera的Target Texture從None換成RenderTexture，也就是將Main Camera的不再輸出到Target Display，而是輸出到Render Texture


![](/assets/7b98d6e88641/1*ZzdlvdYKBEtimRVUCYcatg.png)



![](/assets/7b98d6e88641/1*szvq2zDH5H-SLynqWvRg4Q.png)


可以發現，Main Camera還是有畫面，但是遊戲畫面已經沒有東西了。


![](/assets/7b98d6e88641/1*-EpS4Wblt2UDqVO5gdxHmQ.png)



![](/assets/7b98d6e88641/1*qBKWA8IGvMYdTyLxyLVPag.png)


這個時候可以注意到Main Camera的畫面變成正方形，而且Text變得很大，這是因為此時Main Camera的長寬比不再是依據Display，而是依據Render Texture，Render Texture預設是256x256，我們可以把長寬設成192x108，這樣長寬比就是相同的


![](/assets/7b98d6e88641/1*_098Cwlk7PaNaRIGQFKhtg.png)



![](/assets/7b98d6e88641/1*s7lGQEOIZl-xFBlCeg8YCA.png)


然後是看起來Text變大是因為，我們的Canvas因為Render Camera設成Main Camera，且Main Camera的Target Texture的長寬是192x108，所以Canvas的大小會變成192x108，但是Text的大小不受影響，因此Canvas從1920x1080變成192x108造成Text看起來變大，這邊我們先不理它。
### Render a Quad

接下來，要將這張Render Texture重新畫到Display 1上，我們先創一個Quad，設一個遠一點的地方。


![](/assets/7b98d6e88641/1*nUIN-Kn9GocOi5SFUR3Hmw.png)



![](/assets/7b98d6e88641/1*soG0U3zWoevW05Bsik63mA.png)


然後，在場景中新增一個Camera，把它放到Quad中。


![](/assets/7b98d6e88641/1*U_Ep7TINAwCgU-8teGu1Xg.png)


接著將Camera的位置設成0，然後Clear Flag換成Solid Color，最後將Perspective Projection換成Orthographic Projection。


![](/assets/7b98d6e88641/1*aWt-VLz51PP_24m7t9lvYQ.png)


將將，沒有畫面！


![](/assets/7b98d6e88641/1*Xn26MmcwpYKo_Wz6plFK1A.png)


因為我們的Quad正好在Camera的位置上，我們要將Quad放到Camera前面才看的到，或者說把Camera往後退。


![](/assets/7b98d6e88641/1*ZlPJjoRbOf5T62eTVfSGUA.png)



![](/assets/7b98d6e88641/1*E8hha68iLiSk74YjiwFJEQ.png)


退到\-3就夠了，可以看到畫面上有看到Quad了。


![](/assets/7b98d6e88641/1*3qyryYeR10rW3UeoSMvsqg.png)


可是Quad太小，我們希望它剛好占滿整個畫面，所以我們調整大小成192x108。


![](/assets/7b98d6e88641/1*CKnLul45JkPwjGHJxJn-Zw.png)


然後Camera的Size調成108/2=54，也就是從中心往上的高54，往下的高54，也就是Camera的高是108。


![](/assets/7b98d6e88641/1*GFFBLOlSZvx7NuPGgogAkA.png)


此時可以看到Quad剛好占滿畫面。


![](/assets/7b98d6e88641/1*Kl3RCUG_0-0zWAALUlUURA.png)

### Render “Render Texture”

接下來，我們要將Render Texture貼到Quad上，新增一個Material，Shader選擇Unlit/Texture


![](/assets/7b98d6e88641/1*0A9uExc0vkF-m0UprGoifQ.png)


然後將Base設成Render Texture


![](/assets/7b98d6e88641/1*7D_P7zCCb-Bnb-4KoQv_ZQ.png)



![](/assets/7b98d6e88641/1*bSd6bCdlAqw4uTKt5I_EWw.png)


將將，我們辛苦的把Main Camera的畫面render到Display 1了。


![](/assets/7b98d6e88641/1*_-ufIX3w0DRHHY5toIawJw.png)


這邊可以發現有點鋸齒是因為Render Texture的解析度太低，我們改成1920x1080。


![](/assets/7b98d6e88641/1*eyG43a-13ClHiLhz6RUikg.png)


可以發現比較沒有鋸齒了，Text既然也恢復了，因為畫Text的Canvas長寬也變回了1920x1080


![](/assets/7b98d6e88641/1*ZevsWdrVBxuK1_qANTsFIQ.png)

### Final

最後，終於可以做魚眼效果，就是把Mesh換成Sphere。


![](/assets/7b98d6e88641/1*CWBrGnTaKtE8V_TsijqKfg.png)


可以發現球變成很扁的樣子，因為球的長寬高是192x108x1


![](/assets/7b98d6e88641/1*KD1NmfpZZwx_g3V4-UAI2A.png)


但是在畫面上看起來OK，只是發現Texture有點歪掉，這是因為球的正面會照到畫面中間的1/2，所以我們可以往左移0\.25


![](/assets/7b98d6e88641/1*cvXxK7dis0EvZjy4XorQbQ.png)



![](/assets/7b98d6e88641/1*b-z8D1jVuwvwb70Xg4w6pQ.png)


看起來正常多了，但是如果你想要正常一點的效果不調整Offset，而是將Tiling\.X調成2，那就不會有放大的效果，這個就不放圖了。

事實上，做這些事情大可以用寫Code的方式解決，但是我認為既然都用遊戲引擎了，了解它的設計邏輯比起直接衝下去爆改裡面的東西還更重要，另外，上述的做法還有一個優點是，我們的魚眼是透過Mesh產生，而非數學公式或是Map，這可以讓我們有可能用Mesh的變形來產生任何我們想要的後處理變形效果，這是Shader較難做到的。

最後，這是我事後重做一次的影片。
[](https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fci9iKMPWXs4&display_name=YouTube&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dci9iKMPWXs4&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=google){:target="_blank"}


[![](https://ithelp.ithome.com.tw/storage/image/fbpic.jpg)](https://ithelp.ithome.com.tw/articles/10240164){:target="_blank"}


[https://forum\.unity\.com/threads/render\-a\-canvas\-to\-rendertexture\.272754/](https://forum.unity.com/threads/render-a-canvas-to-rendertexture.272754/){:target="_blank"}

[https://docs\.unity3d\.com/ScriptReference/Texture2D\.ReadPixels\.html](https://docs.unity3d.com/ScriptReference/Texture2D.ReadPixels.html){:target="_blank"}



_[Post](https://medium.com/maochinn/unity-multipass-rendering-7b98d6e88641){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
