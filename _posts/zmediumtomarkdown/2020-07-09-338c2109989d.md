---
title: "FLTK Project Maze"
author: "帽捲"
date: 2020-07-09T07:29:51.772+0000
last_modified_at: 2021-05-10T09:04:23.967+0000
categories: ["Maochinn"]
tags: ["computer-graphics"]
description: "Project頁面: Maze Visibility and Rendering Graphics"
image:
  path: /assets/338c2109989d/1*b17LqQLLlLSxDDTKW-LOpA.png
render_with_liquid: false
---

### FLTK Project Maze

Project頁面: [Maze Visibility and Rendering Graphics](http://dgmm.csie.ntust.edu.tw/?ac1=courprojdetail_CG2012F_3&id=5ecf8d85e9b81&sid=5ecf8d8805e2a){:target="_blank"}


[![](https://opengraph.githubassets.com/fb83ac8012b3ffa05755cd3a2fdd006852b0ea87b7ef392bfc4d86e1e7ae0277/maochinn/MazeVisibility)](https://github.com/maochinn/MazeVisibility){:target="_blank"}


請先下載 [架構](http://dgmm.csie.ntust.edu.tw/?uid=5f069cbd2d631){:target="_blank"} 以及 [範例執行檔](http://dgmm.csie.ntust.edu.tw/?uid=5f069cbd2f008){:target="_blank"} ，跑這個程式前請先把FLTK裝起來，可以看參考我之前寫的 [文章](../cf0c7924631a/) 。Skeleton編譯常見錯誤附在文末。

如果對於OpenGL的矩陣變換不懂也可以參考 [電腦圖學01\-Transformation](../ea46dedf01f9/)


![](/assets/338c2109989d/1*b17LqQLLlLSxDDTKW-LOpA.png)



![Maze](/assets/338c2109989d/1*SzTad4aorsJmUzLBtm4FIA.png)

Maze

這個Project就是要做第一人稱的迷宮，透過滑鼠拖曳在右邊的視窗來移動。迷宮原則上是由天花板、地板、牆壁組成。

原則上使用OpenGL 1\.x的語法實作，也就是利用 _glBegin_ , _glEnd_ 來畫。
### Skeleton

編譯成功後先按Load Maze來載入預先建構的迷宮，迷宮的檔名表示迷宮的大小以前camera的視角，例如：maze\-1x1–45，表示這個迷宮只有1x1個的Cell，45表示視角是45度。


![](/assets/338c2109989d/1*i4Riyk1y6LU1_kJ9c5gM4w.png)



![](/assets/338c2109989d/1*evF9iPl7gk1BeBU2h5JDFg.png)


接下來可以看到Map View已經載入迷宮的資訊了，而Maze View則只有天花板跟地板，利用滑鼠拖曳來移動、旋轉，可以透過Map View來觀察，這個Project就是要把Maze View裡面應該要顯示的第一人稱的畫面。


![](/assets/338c2109989d/1*g3q1q_DKZ0bPa0l0puL1tw.png)


可以觀察一下這個天花板以及地板是如何畫出來的。


![](/assets/338c2109989d/1*8-3X-WucaerJ6YmbL4STrA.png)


在每個frame，我們會先將frame buffer的color buffer清空，然後我們想要將地板畫出來，這邊採用了hack的方式，因為我們想讓地板是無限大的，所以等同於會佔據畫面的下半部，所以這邊先告訴GL要畫方形\( _GL\_QUADS_ \)，然後設定當前的顏色較黑的顏色，然後依序指定左下、右下、右上、左上的Vertex的位置，而天花板則是類似的操作，因為天花板佔據了畫面的上半部。

上面的繪製仍然是在2D空間上，但我們想要畫3D的物件，我們就必須設定相機，或者說是viewer的參數。


![](/assets/338c2109989d/1*wLM6-QU7M-BLrAEdfhsitA.png)


我們在開始畫牆壁之前，我們需要先設定兩種矩陣，分別是Projection matrix與View matrix，它其實對應到相機的內部參數以及外部參數，內部參數指的是相機內部鏡頭的設定，包含長寬比、視角、near clip、far clip，外部參數則是指相機從外部觀察到的位置、朝向。

這邊我們可以先清空frame buffer的深度測試，然後利用 _gluPerspective_ 來設定透視投影的轉換矩陣，再利用 _gluLookAt_ 來設定相機矩陣，這邊因為原始迷宮資料是在X\-Y平面上，但這邊要轉換到XYZ的3D空間，因此我把X\-Y對應到Z\-X平面，這邊當然不是唯一的選擇，只是習慣上會使用Y朝天的3D空間。在這之後，就可以直接畫迷宮了。


![X\-Y plane to Z\-X plane](/assets/338c2109989d/0*yLpEZbs5LPOdvhyj)

X\-Y plane to Z\-X plane


![](/assets/338c2109989d/1*fb5DFFaKN7ae_8rLkxhG1A.png)


我們可以用GL典型的方法來render迷宮，也就是把所有的牆壁都畫出來，然後依據深度替除掉會被遮擋的牆壁，所以我們需要每幀都清空frame buffer中的depth buffer，然後開啟深度測試\(depth test\)，這可以讓被靠近相機的牆壁能夠覆蓋後方的牆壁。依據內部edge的資料來畫每一面牆，而這每一面牆要怎麼畫就取決於前面的矩陣怎麼給。例如如果我是使用Y朝天的3D空間，也就是迷宮坐落於X\-Z平面，所以我們畫牆可以用這樣做：


![](/assets/338c2109989d/1*_f_Fs3vrrLNrGx4IHskv7g.png)


這邊我們就設計牆壁是\+1到\-1的高度。

然後起記得每次重畫的時候需要重新計算新的transformation matrix，所以請記得在上一幀結束或是下一幀開始要把矩陣歸零\(設定成identity matrix\)，否則他要拿目前累積的矩陣再去相乘。


![](/assets/338c2109989d/1*31FUNkazyU_4W24Uosasdw.png)


如果用這樣的做法就可以得到範例程式的結果，但是這個project要求不能使用 _gluPerspective_ 、 _gluLookAt_ 也就是必須自己把矩陣給建構出來，你可以透過 _glGet\(GL\_PROJECTION\_MATRIX\)_ 與 _glGet\(GL\_MODELVIEW\_MATRIX\)_ 來得到目前的矩陣，可以透過這個方式來檢查自己寫的矩陣對不對。

然後也不能使用 _glVertex3_ 來畫，只能使用 _glVertex2_ 來畫，換句話說，我們必須自己把3D vertex利用自己計算的projection matrix和view matrix轉換成2D vertex，也就是我們自己實作出本來GL幫我們做的事情。\(這邊補充一點， _glVertex2_ 其實也是 _glVertex3_ ，只是它把第三個預設填0\)

這邊也提供另個方案實做，這邊可以透過 _glLoadMatrix_ 來把自己建構的矩陣給載入到GL，這邊要注意GL內部的4x4矩陣是一個column\-major 1維陣列，但由於只能使用 _glVertex2_ 來畫，所以我們可以自己使用 _glTranslate_ 或是自己寫的transformation利用 _glMultMatrix_ 來做變換。


![OpenGL Matrix](/assets/338c2109989d/0*UOGMYWwB67gy2JNq.png)

OpenGL Matrix

最後是不能使用深度測試，或是從最遠的牆畫到最近的牆，也就是要自己決定哪些牆壁該畫，哪些牆壁不該畫，換句話說就是只畫真正會顯示到畫面上的牆這邊提供一種方案來實作。


![](/assets/338c2109989d/1*VcOaRanjby2jLnT-Hs4CiQ.png)


以Cell為單位，對於每個Cell的每個Edge，如果是不透明的那就決定要畫哪一段，如果是透明的，那要畫出穿透過去的Cell。整個過程類似如此，但是實際上的edge只會有透明或不透明，不會有部分透明所以實作上較為簡單。


![](/assets/338c2109989d/1*32_uvKboQYDGdC_xovqzBQ.png)



![](/assets/338c2109989d/1*tgob7IJVtRLuxVmQ0qYSeQ.png)



![](/assets/338c2109989d/1*Rxs0f_tWbelxOVTmxnZX-Q.png)



![](/assets/338c2109989d/1*-649s3VrhbXoAmZtkvvSYg.png)



![](/assets/338c2109989d/1*LcME4OBJK9agCPgZrbuKTw.png)


這邊有個小問題可能會遇到，就是當我們自己乘view matrix跟projection matrix完會得到一個\(x, y, z, w\)的向量，而在 [電腦圖學01\-Transformation](../ea46dedf01f9/) 有稍微說明，如果直接把乘完的向量用glVertex4f傳進去是OK的，但是我們這邊要求只能用glVertex2f，所以z=0，w=1，也就是會變成沒有深度資訊，而如果乘出來的w是負的，表示那個vertex在相機背後，所以原則上這個vertex會被捨棄，所以如果直接拿\(x, y, z\)去除負的w，那就會導致座標會跑掉，比如本來在左上角除完負值會跑到右下角，所以如果想保留這個vertex應該是要除abs\(w\)。

這邊要注意的是比較正確的方法應該是所有vertex的w應該都要大於0，如果有一個vertex A、B，如果A\.w &lt; 0，B\.w &gt; 0，那就表示A在相機背後，B在相機前面所以應該要找出AB之間那個w=0的vertex C，然後用C取代A，這樣所有vertex都會在相機前面。但如果你前面在做cell的clip有作對的話，那所有的vertex的w應該都是正數。

這邊稍微解釋一下兩條線相交要怎麼解，假設線可以用起點\(start\)、終點\(end\)來定義


![](/assets/338c2109989d/1*6T7YWAjFXHVIpZT23hruIQ.png)


我們可以用參數式來表示這兩條線


![](/assets/338c2109989d/1*MFQaXyE4ftiKblwRmP7lCg.png)


我們可以回顧一下，如果要解這樣的線性系統，高中應該有教的克拉瑪公式。因為我們要找交集，意思就是兩條線相等的時候。


![](/assets/338c2109989d/1*O5uqJOCebamRwDqHfSfc0Q.png)


把它整理一下可以有兩種解法，第一個就是用上面提到的克拉瑪公式，另一個是找反矩陣，這兩種方式基本上是一樣的


![](/assets/338c2109989d/0*JnndQCqkfsWSwQ8-)


這邊可以解出t跟s，只要帶到對應的線就可以知道相交的位置是甚麼，也可以透過這個參數知道該點有沒有再起點跟終點之間。總之，我們可以看看code的部分是怎麼寫的。


![](/assets/338c2109989d/1*OerbP5W6Rz_glVLQCLqFTg.png)


就是把上面的式子展開來，所以看起來好像不知道在解什麼，這邊注意一下，code的變數跟我上面的代號不是對應的。

這邊補充一些可能會發生錯誤的地方。


![C2086](/assets/338c2109989d/1*P56xKT1vFjueSWiQSPAW3Q.png)

C2086

這個是因為應該要預先\#define WIN32才能正常跑，所以可以在前置處理器先定義WIN32。


![](/assets/338c2109989d/1*_X4FA4yD7x2HdeAS38jlJw.png)


接下來是有可能在GLU會跳出GLAPI有問題，可以嘗試加入


> /\* GLAPI, part 1 \(use WINGDIAPI, if defined\) \*/
 

> \#if defined\( \_ \_WIN32\_ \_ \) && defined\(WINGDIAPI\)
 

> \# define GLAPI WINGDIAPI
 

> \#endif 





> /\* GLAPI, part 2 \*/
 

> \#if \!defined\(GLAPI\)
 

> \# if defined\( \_MSC\_VER\) /\* Microsoft Visual C\+ \+ \*/
 

> \# define GLAPI \_ \_declspec\(dllimport\)
 

> \# elif defined\( \_ \_LCC\_ \_ \) && defined\( \_ \_WIN32\_ \_ \) /\* LCC\-Win32 \*/
 

> \# define GLAPI \_ \_stdcall
 

> \# else /\* Others \(e\.g\. MinGW, Cygwin, non\-win32\) \*/
 

> \# define GLAPI extern
 

> \# endif
 

> \#endif 





> /\* APIENTRY \*/
 

> \#if \!defined\(APIENTRY\)
 

> \# if defined\( \_ \_WIN32\_ \_ \)
 

> \# define APIENTRY \_ \_stdcall
 

> \# else
 

> \# define APIENTRY
 

> \# endif
 

> \#endif 





這個不確定是不是GLU的檔案沒有載對，原則上VS應該要自帶GLU跟GL的，可是如果是自己去網路上載可能會發生這個問題。


![](/assets/338c2109989d/1*To0VfQ8AlUIN5eN831MH0w.png)


通常這個錯會發生在編Release會發生，這個目前還沒有找到治本的方法，但可以先試試看把整個程式最佳會改成否。


![](/assets/338c2109989d/1*EC_bh0NhTlaUh89d7SIvgw.png)




_[Post](https://medium.com/maochinn/fltk-project-maze-338c2109989d){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
