---
title: "„ÄêOmniverse„ÄëDevelopment 102: Scripting Properties and Metadata"
author: "Â∏ΩÊç≤"
date: 2025-02-06T10:15:15.386+0000
last_modified_at: 2025-02-06T10:21:11.872+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","openusd"]
description: "In „ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas, we learned how to directly modify the content of¬†.usd to add and‚Ä¶"
image:
  path: /assets/b8e7a81710ee/1*ICKb_BFwpmxz-bRXHJp-zw.png
render_with_liquid: false
---

### „ÄêOmniverse„ÄëDevelopment 102: Scripting Properties and Metadata

‰∏≠ÊñáÁâàÊú¨Ôºö [„ÄêOmniverse„ÄëÂ≠∏ÁøíÁ≠ÜË®ò ‚Äî 05ÔºöProperty and Metadata](../a7fa6a26a49a/)

In [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/) , we learned how to directly modify the content of \.usd to add and modify the prim in the layer\. This article will use the OpenUSD API in the built\-in **Script Editor** of Omniverse to interact with all the data in the prim and even the stage\. You can think of it as modifying the \.usda file through Python Script instead of manually modifying the content as we did in the past\.

In order to use **Script Editor** in Omniverse, a more convenient way is to start it in debug mode\. For details, please refer to [„ÄêOmniverse„ÄëDevelopment 101: Getting Started with Kit\-Based Development](../78f8915183be/) \.
```typescript
.\repo.bat launch -d
```

Whether it is Composer or Editor, you can find it in Menu \(Developer &gt; Script Editor\) after launching it


![Figure 1: Developer > Script Editor](/assets/b8e7a81710ee/0*6gjgZJh3N0NbgXg9.png)

Figure 1: Developer > Script Editor

When the Script Editor is opened, as shown on the left, it allows you to quickly try out some API functions\. Of course, you can also create an extension to test the API yourself\. At this time, you can use VS Code Link to trace to the bottom layer, **but this article only needs to use Script Editor** \.


![Figure 2: Script Editor](/assets/b8e7a81710ee/1*tKA1MMTsIMc1h01QSXQtbw.png)

Figure 2: Script Editor
### Learn OpenUSD: Using Attributes

The course mainly talks about how to use the OpenUSD API to set/get prim‚Äôs attributes\. For example, it is like the `size` of the `Cube` in [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/) \.

Of course, we can achieve this by directly modifying \.usda manually, but we can also automate the operation through scripts\.

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-19+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-19+V1){:target="_blank"}

We can first use the OpenUSD Python API to create a prim to try it out\. First, manually clear all prims in the entire stage, then enter the following script in the Script Editor, and then press Run, as shown in the lower left corner of Figure 2
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()

scope = UsdGeom.Scope.Define(stage, "/Geometry")
xform = UsdGeom.Xform.Define(stage, scope.GetPath().AppendChild("GroupTransform"))
cube = UsdGeom.Cube.Define(stage, xform.GetPath().AppendChild("Box"))
```

You should see that the result of the entire stage is like the result of opening [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} \. We can save it as another \.usda and compare it\.


![Figure 3: MyModel\.usda in stage](/assets/b8e7a81710ee/1*ICKb_BFwpmxz-bRXHJp-zw.png)

Figure 3: MyModel\.usda in stage

The result should look something like below, just like putting [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} into Omniverse and saving it\. You can refer to the previous [result](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#82a9){:target="_blank"} , which will have a bunch of settings generated by Omniverse\.
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

With this, we have a preliminary understanding of using the OpenUSD API\. We can create \.usd manually or through the API\. At the same time, since we can manually modify the prim data, just like what is done in [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/) , we can do similar things through the API\. 
First, let‚Äôs start with the Attributes of the Property\.
#### Attributes

In fact, the ‚Äú **real data** ‚Äù in prim is divided into two categories, Property and Metadata\.

Attributes belong to Property, just as mentioned in [„ÄêOmniverse„ÄëDevelopment 102: Learning OpenUSD](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#76cd){:target="_blank"} , so here we use [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} as an example and add a simple Attributes in it, similar to what was done in [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/) , add a `size` of type `double` , copy the following script to the Script Editor and Run\.
```css
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
scope = UsdGeom.Scope.Define(stage, "/Geometry")
xform = UsdGeom.Xform.Define(stage, scope.GetPath().AppendChild("GroupTransform"))
cube = UsdGeom.Cube.Define(stage, xform.GetPath().AppendChild("Box"))
size_attr = cube.GetPrim().CreateAttribute("size", Sdf.ValueTypeNames.Double)
size_attr.Set(1.0)
```

As a result, you should see that the ‚ÄúBox‚Äù has become larger\. After saving, the result is as follows
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double size = 4
        }
    }
}
```

Basically, just do the same simple thing as before\. At the same time, we can find one thing, the first half of the script is to **define prim** , and the second half is to **set the value of prim‚Äôs attribute** \. If there is already a prim in the scene, it is better to use **get method**
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
    size_attr = box_prim.CreateAttribute("size", Sdf.ValueTypeNames.Double)
    size_attr.Set(1.0)
```

This makes the script much simpler\. Let‚Äôs focus on modifying the attribute\. You can notice that before we set the value, we must first create, or get the `size` attribute, before we can set it further\.

This approach is very intuitive\. You can create any attribute you want, regardless of whether it is legal or not\. In other words, if you accidentally write the wrong name, such as `s1ze` , it will not report any errors, but the `"Box"` on the screen will not respond\. If we save it, we will find
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            custom double s1ze = 4
        }
    }
}
```

Here, we can notice that `s1ze` is indeed created, but at the same time, we can find that there is an additional `custom` in front of `s1ze` , which means that this attr is created by the user and has no preset purpose\. In other words, Omniverse cannot recognize the function corresponding to this attr\. Therefore, the more recommended approach is to use [IsA Schema](https://medium.com/maochinn/omniverse-development-102-working-with-prims-and-default-schemas-5732179f7159#6ce1){:target="_blank"} \.
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  cube = UsdGeom.Cube(box_prim)
  size_attr = cube.CreateSizeAttr()
  size_attr.Set(4.0)
```

More specifically, it is **Cube Schema** , because `"Box"` is a Cube, so first we have to convert Box from a simple prim to a prim under the `UsdGeom.Cube` schema, so that we can use the method designed in the `UsdGeom.Cube` schema, that is, `CreateSizeAttr()` , on `"Box"` \.

Because the Cube Schema uses the value of the `size` attr to change the size of the Cube, the Schema provides the `CreateSizeAttr()` method to help us create the corresponding attribute\. During the whole process, we do not need to know the correct attribute name, we only need to use the API to ensure that we can create the correct attribute\.

The advantage of using the method provided by Schema is that the name will not be misspelled and it is more readable\. Of course, there are other benefits, which will be illustrated by more complex examples later\. 
In short, in theory, both approaches are acceptable, but you can notice that here we create the attribute first and then set the value\. Conversely, if we want to get the value, we must first get the attribute before getting the value\.
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  cube = UsdGeom.Cube(box_prim)
  size_attr = cube.CreateSizeAttr()
  size_attr.Set(4.0)
  # Get the size, display color, and extent attributes of the cube
  cube_size: Usd.Attribute = cube.GetSizeAttr()
  print(f"Size: {cube_size.Get()}")
```

After that, the next slightly more complicated operation is to move the `"Box"` to a specific location, in other words, to set the **Translate** , or more precisely, to set the **Translate** in the Transformation\. Following the same method is like
```python
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  xformable = UsdGeom.Xformable(box_prim)
  translate_op = xformable.AddTranslateOp()
  translate_op.Set(Gf.Vec3f(1, 2, 3))
```

We want to move `"Box"` to the position \(1, 2, 3\) \. We can use the `UsdGeom.Xformable` schema\. After executing the save operation, we can find that there are more than one additional attribute\.
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double3 xformOp:translate = (1, 2, 3)
            uniform token[] xformOpOrder = ["xformOp:translate"]
        }
    }
}
```

In fact, similar [result](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#82a9){:target="_blank"} have been seen before\. `xformOp:translate` is the position to be set\. In addition, there is `xformOpOrder` \. In short, `xformOp` has three types of Ops, namely **scale, rotate and translate** \. The three Operators are not commutative, so **order** is very important\. As long as transformation is involved, the `xformOpOrder` attribute must be present\.

At this point you can see the advantage of [IsA Schema](https://medium.com/maochinn/omniverse-development-102-working-with-prims-and-default-schemas-5732179f7159#6ce1){:target="_blank"} \. Even if you don‚Äôt know the exact name of attribute or the associated attribute, you can still use the function normally\. Although you still need to know the name of the function, there will be an error reminder if you make a typo\. Of course, things are not always so beautiful\. In Python API, it is a bit verbose to get the value of `xformOp:translate` \.
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
xformable = UsdGeom.Xformable(box_prim)
    
translate_op = None
for op in xformable.GetOrderedXformOps():
    if op.GetOpType() == UsdGeom.XformOp.TypeTranslate:
        translate_op = op
        break
    
if translate_op:
  translate_attr = translate_op.GetAttr()
  translate_value = translate_attr.Get()
  print(translate_value)
```

If we want to get the exact value of translate, we must first get all the `xformOp` , then identify the `xformOp:translate` based on the type, then get the translate attribute, and finally get the value\.
Of course, we can still use a more general method
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
xformable = UsdGeom.Xformable(box_prim)
if box_prim:
    translate_attr = prim.GetAttribute("xformOp:translate")
    translate_value = translate_attr.Get()
```

Basically the same result can be achieved\. If you know how attribute works in advance, this approach is even more convenient\. You can get the specified attribute directly through `GetAttribute` \. Of course, if you are really lazy, you can directly create a new one through `CreatAttribute` to overwrite the old one, and then directly call get/set to perform subsequent operations\.

In short, compared to manually modifying \.usd, we can also write a script to call the OpenUSD API, and then the API code will modify \.usd\.

Currently, there are two main ways to modify attribute using scripts\. One is to use the [IsA Schema](https://medium.com/maochinn/omniverse-development-102-working-with-prims-and-default-schemas-5732179f7159#6ce1){:target="_blank"} , such as the methods provided by `UsdGeom.Cube` and `UsdGeom.Xformable` , to modify it\. The other is to directly use the method of `Usd.Prim` to modify it, that is, CreateAttribute\( \) \. 
Although the former may be more verbose, the advantage is that if the operation mode of Schema changes in the future, such as the name of attribute changes or other attribute is added, we do not need to modify the code, **just call the latest version of the method** \. At the same time, calling the method also makes the overall readability of the code higher\. The advantage of the latter is that it can operate data more directly, which is closer to manually modifying files and is suitable for debugging\.

In fact, taking the example of moving a prim, there is a more detailed approach, which is also provided by the official course\.
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
UsdGeom.XformCommonAPI(box_prim).SetTranslate(Gf.Vec3d(1, 2, 3))
```

This method is the API Schema mentioned in the [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/) \. It only requires one line, but this method usually only has APIs available for common functions\. At the same time, it is also confusing\. There are so many ways to achieve the same function\. Which method is better? In fact, I just listed the methods of OpenUSD\. Omniverse kit also has its own API to do similar things, so this issue is beyond the scope of this article and will be introduced later\.

In short, there are many ways to add and adjust Attributes\. The most fundamental method is to modify \.usd directly, or call the designed API to modify \.usd\. This will avoid many human errors\. Of course, you can also interact through the Omniverse interface, but in fact, it is also calling the API behind it\. Relatively speaking, if you know how to use the API, you can also do the same thing, and you can also customize your own scripts and even functions that are not available in the interface\.

[**Universal Scene Description: UsdGeomXformable Class Reference**](https://openusd.org/dev/api/class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b){:target="_blank"} 
[_Base class for all transformable prims, which allows arbitrary sequences of component affine transformations to be‚Ä¶_ openusd\.org](https://openusd.org/dev/api/class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b){:target="_blank"}
#### Relationship

In addition to Attributes, Property also contains Relationship\. Somehow you can regard Relationship as a special Attributes, except that it stores a pointer, which will point to the prim in the stage\. We can try to open [_Layout\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#188a){:target="_blank"} and execute the script
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
world_prim = stage.GetPrimAtPath("/World")

custom_relationship: Usd.Relationship = box_prim.CreateRelationship("myCustomRelationship")
custom_relationship.SetTargets(["/World"])
```

We store a relationship in `"Box"` which stores the location of `"World"` \. If you only look at it from the script, you can even think that the relationship is an attributes that stores a string, but after saving, check [_Layout\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#188a){:target="_blank"} to see the difference\.
```python
#usda 1.0

#...
over "Geometry"
{
    over "GroupTransform"
    {
        over "Box"
        {
            rel myCustomRelationship = </World>
        }
    }
}
```

It does not look like a simple string\. In fact, the relationship points to a specific prim in the stage\. In other words, this prim may be composed of different layers\. It is not a prim in a specific layer or a specific \.usd\.

However, the relationship itself has no special purpose\. It is for people who use the prim later to know which prims are related to it\. Therefore, it does not usually appear very often, especially in simple projects that do not involve scripts\.

[**Create a Relationship ‚Äî Omniverse Developer Guide**](https://docs.omniverse.nvidia.com/dev-guide/latest/programmer_ref/usd/properties/create-relationship.html){:target="_blank"} 
[_Universal Scene Description \(OpenUSD\) code samples for creating a Relationship\._ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/dev-guide/latest/programmer_ref/usd/properties/create-relationship.html){:target="_blank"}

[**Universal Scene Description: UsdRelationship Class Reference**](https://openusd.org/release/api/class_usd_relationship.html){:target="_blank"} 
[_A UsdRelationship creates dependencies between scenegraph objects by allowing a prim to target other prims, attributes‚Ä¶_ openusd\.org](https://openusd.org/release/api/class_usd_relationship.html){:target="_blank"}
#### Metadata

In addition to storing Properties, Prim can also store Metadata\. As the name implies, it is data about data, such as the name of the author who created the data and comments about the data, that is, data that supplements the description of this prim\. 
At first glance, it is similar to attribute in form, and you may think that this is similar to the function of attribute, but metadata is different from attribute because metadata does not need to be resolved or interpolated\. In other words, metadata will mostly not be changed, but can be overwritten\.

[**Universal Scene Description: Object Model and How the Classes Work Together**](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"} 
[_An SdfLayer provides the interface to a persistent \(in a file\) or in\-memory only \(via ‚Äúanonymous‚Äù layers\) container of‚Ä¶_ openusd\.org](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"}

Another difference is that metadata cannot be customized because it is **strongly typed** \. In other words, only registered reserved words can be used\.

[**Universal Scene Description: Object Model and How the Classes Work Together**](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"} 
[_An SdfLayer provides the interface to a persistent \(in a file\) or in\-memory only \(via ‚Äúanonymous‚Äù layers\) container of‚Ä¶_ openusd\.org](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"}

For example, comment belongs to metadata\. After opening [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} and executing the script, we add some description to `"Box"`
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  box_prim.SetMetadata('comment', "A prim of Cube")
  print(box_prim.GetMetadata('comment'))
```

After saving, check \.usda and you will find brackets after the prim name\. The information inside is metadata\.
```python
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            "A prim of Cube"
        )
        {
        }
    }
}
```

Of course, there is more metadata than this one\. Next, we will introduce two other types of metadata\.
### Learn OpenUSD: Understanding Model Kinds

The course introduces a relatively commonly used metadata, **kind** , which is divided into group, assembly, and component\. To put it simply, it allows people to define the hierarchy of each prim themselves\. Kind is the Categories of prim in the hierarchy\.
For example, furniture is a component, which is basically the basic unit and cannot be divided any further\. Of course, there are still subcomponents that can be used\. Several pieces of furniture can be grouped together, and the entire building is an assembly\.

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-22+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-22+V1){:target="_blank"}

A straightforward explanation is that each prim has a **tag** called kind, and the possible values ‚Äã‚Äãare **group, assembly, component and subcomponent\.** However, you can basically decide for yourself what kind of prim belongs to which kind\. In other words, this requires communication with the team and synchronizing everyone‚Äôs consensus, otherwise this kind will have no real benefit\.
In other words, the kind of each prim is **completely custom** , and may not even be defined, because there is no standard answer for this kind, and it only requires the team to reach a consensus\.


![Figure 4: Kind](/assets/b8e7a81710ee/1*VxEiWi94C6kSr9k3zx5U2Q.png)

Figure 4: Kind

In the Omniverse Property, you can find the Kind of the prim \(although it is not a Property\) \. There are four options to choose from\. We can use [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} as an example again, set `"Box"` as a group and save it\.
```python
#usda 1.0

#...
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            kind = "group"
        )
        {
        }
    }
}
```

What if we want the script to do that? Suppose we want to change kind to subcomponent
```css
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
 box_prim.SetMetadata('kind', "subcomponent")
 print(box_prim.GetMetadata('kind'))
```

After saving, you can check \.usda
```python
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            kind = "subcomponent"
        )
        {
        }
    }
}
```

Âè™ÊòØÈÄôÈÇäË¶ÅÊ≥®ÊÑè `SetMetadata()` ‰∏≠Á¨¨‰∏ÄÂÄãÂèÉÊï∏Ôºå‰πüÂ∞±ÊòØmetadataÁöÑÂêçÁ®±Â¶ÇÊûúÈö®ÊÑèÂèñÂêçÊúÉË∑≥Âá∫ÈåØË™§\(Unregistered metadata key\)ÔºåÈÄôÊòØÂõ†ÁÇ∫Â¶ÇÂâçÈù¢ÊâÄËø∞metadataÁöÑÁ®ÆÈ°ûÊòØ‰∫ãÂÖàË®≠Ë®àÂ•ΩÁöÑÔºå‰∏çËÉΩÈö®‰æøÂ¢ûÂä†Á®ÆÈ°û„ÄÇ

‰ΩÜÊàëÂÄëÊ≤íÊúâÂøÖË¶Å‰ΩøÁî®Âà∞ÊâÄÊúâÁöÑmetadataÔºåÊú¨ÁØáÊúÄÂæåÂú®‰ªãÁ¥π‰∏ÄÁ®ÆmetadataÔºåactive„ÄÇ
### Learn OpenUSD: Traversing Stages

This tutorial will demonstrate how to use a script to traverse all prims in the entire stage, but in the process, the **active** metadata will be introduced, which will affect whether the Prim will be considered when traversing the stage\.

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-21+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-21+V1){:target="_blank"}

Open [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} and execute the script
```python
from pxr import Usd, UsdGeom, Sdf

stage = omni.usd.get_context().get_stage()
for prim in stage.Traverse():
 print(prim.GetPath().pathString)
```

The script simply uses a for loop to iterate over all prims\. We expect the output to be the three prims in [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} , but the actual output is as follows
```bash
/Geometry
/Geometry/GroupTransform
/Geometry/GroupTransform/Box
/OmniverseKit_Persp
/OmniverseKit_Front
/OmniverseKit_Top
/OmniverseKit_Right
/OmniKit_Viewport_LightRig
/OmniKit_Viewport_LightRig/Lights
/OmniKit_Viewport_LightRig/Lights/DomeLight
/OmniKit_Viewport_LightRig/Lights/DistantLight
/Render
/Render/OmniverseKit
/Render/OmniverseKit/HydraTextures
/Render/OmniverseKit/HydraTextures/omni_kit_widget_viewport_ViewportTexture_0
/Render/Vars
/Render/Vars/LdrColor
```

It can be found that only the first three belong to the [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} layer\. As for the other prims, they are built\-in in Omniverse\. You can‚Äôt even see them in the Stage\. In fact, these things do not exist in our own layer, but it is more like Omniverse has its own preset layer, which exists inside the App\.

At the same time, this also brings a problem\. We cannot intuitively know what is in the stage\. Our \.usda cannot fully represent the current stage\. This is the biggest difference between Omniverse and pure OpenUSD\. It also proves that **Omniverse is a platform based on OpenUSD but with additional architecture** \.

At this point, if you only want to find the prim of a specific schema, such as Scope and Cube, you can execute the script
```python
from pxr import Usd, UsdGeom, Sdf

stage = omni.usd.get_context().get_stage()
for prim in stage.Traverse():
 if UsdGeom.Scope(prim):
  print(prim.GetPath().pathString)
 elif prim.IsA(UsdGeom.Cube):
  print(prim.GetPath().pathString)
```

This will only output
```rust
/Geometry
/Geometry/GroupTransform/Box
```
#### Active/Inactive

Next is the **active** metadata\. Open [_MyModel\.usda_](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5#dd89){:target="_blank"} and execute the following script
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  box_prim.SetMetadata('active', False)
```

After saving, you can see that the metadata of `"Box"` has an additional active
```ruby
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            active = false
        )
        {
        }
    }
}
```

At the same time, the `"Box"` of the Stage in Omniverse has also changed, and you can find that there are more prohibited symbols\.


![](/assets/b8e7a81710ee/1*LURU9tKGfdbZOQq31dt5og.png)


At this point, re\-execute the Traverse script and you will find that the output is only
```rust
/Geometry
```

There are other metadata, but I won‚Äôt list them all here\. You can try them yourself or search using GPT\. For example:
1. `hidden` ÔºöThis metadata key is used to mark whether a primitive object is hidden\. Equivalent to calling the `UsdPrim::SetHidden()` method\.
2. `kind` ÔºöThis metadata key is used to specify the type of primitive object \(e\.g\., group, component, etc\. \) \.
3. `assetInfo` ÔºöThis is a dictionary used to store information related to the asset, such as the asset‚Äôs name, version, etc\.
4. `documentation` ÔºöThis metadata key is used to store documentation or descriptive information related to the original object\.
5. `comment` ÔºöThis metadata key is used to store comments or notes related to the original object\.
6. `customLayerData` ÔºöThis is a dictionary used to store custom layer data\.
instanceable: This metadata key is used to mark whether a primitive object is instantiable\.
7. `instanceable` ÔºöÈÄôÂÄãÂÖÉÊï∏ÊìöÈçµÁî®ÊñºÊ®ôË®ò‰∏ÄÂÄãÂéüÂßãÁâ©È´îÊòØÂê¶ÂèØÂØ¶‰æãÂåñ„ÄÇ


In short, as in the example of kind, metadata is like the tag of prim
### Conclusion

In summary, this article mainly introduces the data in prim, which is divided into **Property** and **Metadata** \. In this way, we basically have a general understanding of the composition of prim\. In addition, it also introduces how to execute simple scripts in Omniverse\. At the same time, you can compare the changes in the screen and \.usd, and basically you can explore more deeply\.
For example, the **Value resolution** that I skipped is about the strategy for attribute parsing, because the value of attributecomes from three sources\.
- Value clips
- Authored timeSamples
- Default value


Simply put, the first two are related to the **animation** system, because compared to metadata, the feature of **attribute** is that it will be **interpolated over time\.** The last one is the default value stored in **attribute** itself\. The priority is from top to bottom\. If there is no animation, most of the time the default value is used\.

It is worth noting that for attributes with the same name but in different layers, the attribute with the strongest opinion will eventually win\. At this time, the value of the prim attribute composed on the stage is the Default value\. In other words, the value of the attribute in the stage in this article and even in previous articles is the **Default value** \.

The details will be introduced in the next article\.

Thank you for reading\! If you found my article helpful or have any feedback, feel free to reply\. If you‚Äôd like to support me, you can:
- Clap üëè or share your thoughts üí¨
- [Follow me on Medium](https://medium.com/@maochinn){:target="_blank"}
- [Subscribe to me on Medium](https://medium.com/maochinn){:target="_blank"}
- [Connect with me on LinkedIn](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


You can also check out my other series of articles:
- [„ÄêOmniverse„ÄëDevelopment 101: Getting Started with Kit\-Based Development](../78f8915183be/)
- [„ÄêOmniverse„ÄëDevelopment 101: Understanding Applications and Extensions](../1d990d98b7f9/)
- [„ÄêOmniverse„ÄëDevelopment 101: Kit Workshop SIGGRAPH 2022](../310a189add0b/)
- [„ÄêOmniverse„ÄëDevelopment 102: Learning OpenUSD](../59dee6c16bd5/)
- [„ÄêOmniverse„ÄëDevelopment 102: Working With Prims and Default Schemas](../5732179f7159/)



_[Post](https://medium.com/maochinn/omniverse-development-102-property-and-metadata-b8e7a81710ee){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
