---
title: "【Omniverse】學習筆記 — 03：OpenUSD"
author: "帽捲"
date: 2024-11-27T14:34:53.586+0000
last_modified_at: 2025-02-27T07:24:27.155+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","openusd"]
description: "在之前的【Omniverse】學習筆記 — 02：Kit Workshop SIGGRAPH…"
image:
  path: /assets/be14a4a5704f/0*09cRzp4gjAR9xJv2
render_with_liquid: false
---

### 【Omniverse】學習筆記 — 03：OpenUSD

English Version: [【Omniverse】Development 102: Learning OpenUSD](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5?source=---------1-----------------------){:target="_blank"}

在之前的 [【Omniverse】學習筆記 — 02：Kit Workshop SIGGRAPH 2022](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-02-kit-workshop-siggraph-2022-2183284ed751?source=---------1-----------------------){:target="_blank"} 中我們有人工的修改過\.usda檔案，可以知道Omniverse中的所有物件，或者更準確的說，Prim\(itive\)，都是透過OpenUSD來修改，無論是直接修改\.usd檔，或是使用OpenUSD API來修改。

因此，在進入更進階的Kit\-based Omniverse的實際應用，我們必須進一步地來學習OpenUSD，這是因為，與其說Omniverse是可以輸入輸出\.usd檔案的軟體，不如說，Omniverse是基於OpenUSD的軟體。
#### 目錄
- Learn OpenUSD: Learning About Stages, Prims and Attributes
- Stage and Scene
- Prim
- 結論


官網的Banner是這樣描述NVIDIA Omniverse的。


> The platform for developing **OpenUSD** applications for industrial digitalization and generative physical Al\. 






![[https://www\.nvidia\.com/en\-us/omniverse/](https://www.nvidia.com/en-us/omniverse/){:target="_blank"}](/assets/be14a4a5704f/0*09cRzp4gjAR9xJv2)

[https://www\.nvidia\.com/en\-us/omniverse/](https://www.nvidia.com/en-us/omniverse/){:target="_blank"}

Omniverse是一個平台，可以在其上開發出來的OpenUSD application，換言之，無論是 [【Omniverse】學習筆記 — 01：Application and Extension](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-01-application-and-extension-e765192086c8?source=---------2-----------------------){:target="_blank"} 中提到的Application與Extension都是圍繞著OpenUSD所以開發。

因此，本文及後續會參考NVIDIA的Learning Path來介紹OpenUSD，與官方的Course不同的是，我將以Omniverse Kit\-based Application來展示，而不單純使用OpenUSD的API，因為如同上述所言，Omniverse Kit不過是其中一種OpenUSD的方案，換言之，在實際使用上會有一些異同。


![[https://www\.nvidia\.com/en\-us/training/](https://www.nvidia.com/en-us/training/){:target="_blank"}](/assets/be14a4a5704f/1*b-1PDP12B7CyS_jbmPv_zw.png)

[https://www\.nvidia\.com/en\-us/training/](https://www.nvidia.com/en-us/training/){:target="_blank"}


[![](https://www.nvidia.com/content/dam/en-zz/Solutions/learn/learning-path/openusd/learn-openusd-og-1200x630.jpg)](https://www.nvidia.com/en-us/learn/learning-path/openusd/){:target="_blank"}


官方的Course都是透過線上的Jupyter去執行，每次啟動大概要等5分鐘，Launch會開整個資料夾給你，可以自已開notebook。


![](/assets/be14a4a5704f/1*lcQigfOC8-p7J20LS3D8vw.png)



![](/assets/be14a4a5704f/1*N__SLlz9RbX3Ov-v2P8O_Q.png)


可能有一些小錯需要自己修正，例如漏給了第一個參數
```ini
prim = UsdGeom.Xform.Define('/ExamplePrim')
```

應該改成
```ini
prim = UsdGeom.Xform.Define(stage, '/ExamplePrim')
```

至於詳細就跟著課程一步一步來。

本文主要還是著重在Omniverse，因此不會將course中的所有內容透過Omniverse操作一遍，詳細的OpenUSD的理論部分還是需要參照官方的Course，本文只是選取部分重要的內容在Omniverse Kit實踐。

除此之外，因為Omniverse介面上無法控制與檢視所有物件的資訊，因此我們還是需要使用VS Code來檢視原始的\.usd檔\( \.usda\)，這邊推薦安裝USD Language這個extension來控制以及檢視前後的變化。


![](/assets/be14a4a5704f/1*djlcPTSmUA6tWlQrLhqelA.png)

### Learn OpenUSD: Learning About Stages, Prims and Attributes

為了瞭解OpenUSD，我們得先要了解Stages, Prims and Attributes，一個比較粗淺的理解是，\.usd中如何描述一個物件，它可以是Mesh, Light等，這個物件就是Prim，多個Prim則可以組成stage，Prim中的資料則是Attributes。

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-17+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-17+V1){:target="_blank"}

為了在Omniverse Kit中能夠表現Course中的結果，這邊可以採用Omniverse USD composer來做相關的示範，這在之前文章 [【Omniverse】學習筆記 — 00：Kit\-based Development](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-00-kit-based-development-a54ae65f22bf?source=your_stories_page-------------------------------------){:target="_blank"} 中的Course就有學到了。詳細的操作可以參考

[**USD Composer Overview \- Omniverse USD Composer**](https://docs.omniverse.nvidia.com/composer/latest/index.html){:target="_blank"} 
[_NVIDIA Omniverse™ USD Composer is an Omniverse app for world\-building that allows users to assemble, light, simulate…_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/composer/latest/index.html){:target="_blank"}

或者你也可以用更加輕量化的usdview

[**usdview Quickstart — Omniverse USD**](https://docs.omniverse.nvidia.com/usd/latest/usdview/quickstart.html){:target="_blank"} 
[_Warning The python environment batch file currently only works in Windows Command Prompt so you will need to use that…_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/usd/latest/usdview/quickstart.html){:target="_blank"}

總之，先用VS code建立一個名為MyModel\.usda的檔案，
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

要注意的地方是最好取名要是\.usda，而不是\.usd，因為USDA\(scii\)才是給人類看的。除此之外還有USDC\(compressed\)、USDZ\(ipped\)。

如果成功的話，可以在右上角的 _Layer_ 中可以看見對應 _MyModel\.usda_ 檔案的結構。


![](/assets/be14a4a5704f/1*W1nDlI-N6raSxITzb4IgFQ.png)


如果切換到 _Stage_ ，也可以看到類似的結構。


![](/assets/be14a4a5704f/1*rpFzm8WuJQWkxuN20MzIaA.png)


從這個例子我們看不太出來 _Stage_ 與 _Layer_ 的差別，我們不妨再增加一個\.usda，不過這次我們用App新增的功能，從左上角的file去new。


![](/assets/be14a4a5704f/1*tZSxHkU6CuJnm9WDKYbmDQ.png)


預設的Layer包含地板、燈光，此時我們切換L _ayer_ 跟 _Stage_ 仍然可以發現他們是相同的。


![](/assets/be14a4a5704f/1*onwDkCKpFfWayyfq68DvWA.png)


此時選擇 _Layer_ 中的 **_Insert Sublayer_** ，選擇 _MyModel\.usda_ ，可以發現在 _Root Layer_ 中多了一個 _MyModel\.usda_ ，事實上，你完全可以把一個\.usd檔當作是一層layer，但是layer不一定會有\.usd，因為，我們此時尚未將new出來的這個root layer儲存成\.usda。


![](/assets/be14a4a5704f/1*UrTAmkqG-bDB13fKkNNjzA.png)



![](/assets/be14a4a5704f/1*_TPlNXom0-ijkJCpdbmLrw.png)


但是在大多數的情況下，\.usd幾乎就等同於layer，只是layer在語意上多了上下的階層關係，我 _們_ 不妨先把這個 _Root layer_ 儲存成 _Layout\.usda_ ，並且打開，應該會長得像跟這樣，因為篇幅關係我就省略大量的attribute，只留下重要的部分。
```python
#usda 1.0
(
    customLayerData = {
        # ...
    }
    defaultPrim = "World"

    subLayers = [
        @./MyModel.usda@
    ]
)

def Xform "World"
{
}

def Xform "Environment"
{
    # ...

    def DomeLight "Sky" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        # ...
    }

    def DistantLight "DistantLight" (
        prepend apiSchemas = ["ShapingAPI"]
    )
    {
        # ...
    }

    def Scope "Looks"
    {
        def Material "Grid"
        {
            # ...
            def Shader "Shader"
            {
                # ...
            }
        }
    }

    def Mesh "ground" (
        prepend apiSchemas = ["MaterialBindingAPI"]
    )
    {
        # ...
    }

    def Plane "groundCollider" (
        prepend apiSchemas = ["PhysicsCollisionAPI"]
    )
    {
        # ...
    }
}
```

基本上內容跟我們在 _USD Composer_ 中的 _Layer_ 看得一致，可以注意的是
```ini
subLayers = [
        @./MyModel.usda@
    ]
```

這行就表示 _MyModel\.usda_ 是 _Layout\.usda_ 這個layer的Sub\-layer，那它究竟有什麼效果呢？我們可以打開 _Stage_ 看看


![](/assets/be14a4a5704f/1*NPnwvpaPJN6XhkC5xj7flg.png)


可以看到 _Layout\.usda_ 包含了 _MyModel\.usda_ 的內容，更有趣的是，如果我們將 _MyModel\.usda_ 更改成這樣
```python
#usda 1.0

def Xform "World"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

我們將 _Scope “Geometry”_ 改成 _Xform “World”_ ，直覺上，我們可以想像在Stage中會出現兩個World，但Stage顯示兩個Layer的World合併了，結果只有一個World在Stage中。

我們可嘗試在 _Layout\.usda_ ，也就是目前這個 _Root Layer_ 添加一個Cube


![](/assets/be14a4a5704f/1*VvjNFyHTl6WON56kIYLeSw.png)



![](/assets/be14a4a5704f/1*9TQZNZ1te1zC4vC-4EXRXg.png)


儲存後觀察 _Layout\.usda_ 的變化，可以發現world中有了內容，長得像是：
```python
def Xform "World"
{
    def Mesh "Cube"
    {
        float3[] extent = [(-50, -50, -50), (50, 50, 50)]
        int[] faceVertexCounts = [4, 4, 4, 4, 4, 4]
        int[] faceVertexIndices = [0, 1, 3, 2, 4, 6, 7, 5, 6, 2, 3, 7, 4, 5, 1, 0, 4, 0, 2, 6, 5, 7, 3, 1]
        normal3f[] normals = [(0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, 1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 0, -1), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, 1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (0, -1, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (-1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0), (1, 0, 0)] (
            interpolation = "faceVarying"
        )
        point3f[] points = [(-50, -50, 50), (50, -50, 50), (-50, 50, 50), (50, 50, 50), (-50, -50, -50), (50, -50, -50), (-50, 50, -50), (50, 50, -50)]
        texCoord2f[] primvars:st = [(0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0), (0, 1), (0, 0), (1, 0), (1, 1), (0, 0), (1, 0), (1, 1), (0, 1), (0, 0), (1, 0), (1, 1), (0, 1), (1, 0), (1, 1), (0, 1), (0, 0)] (
            interpolation = "faceVarying"
        )
        uniform token subdivisionScheme = "none"
        double3 xformOp:rotateXYZ = (0, 0, 0)
        double3 xformOp:scale = (1, 1, 1)
        double3 xformOp:translate = (55.72931671142578, 0.000008976281606010161, -60.18137741088867)
        uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
    }
}
```

有些數值可能不大相同，但是你可以注意到，第一，在 _Layout\.usda_ 中的 _”World”_ 並不包含Box，因為Box的定義在 _MyModel\.usda_ 中， _Layout\.usda_ 透過 _subLayers_ 來找到Box的定義，第二，因為我們目前的Authoring Layer是 _Layout\.usda_ ，所以所有的更動都會在 _Layout\.usda_ 中，因此新增的 _”Cube”_ 會在 _Layout\.usda_ 中。

一個值得注意的是，Omniverse新增Cube這個物件\(Prim\)的類型\(Scheme\)是Mesh，需要自己定義八個vertices，OpenUSD的Course則是直接使用Cube這個Scheme。

總之，此時Stage跟Layer的差別就出現了


![](/assets/be14a4a5704f/1*eDXSSezdd5zi_n9L1z7quA.png)



![](/assets/be14a4a5704f/1*wPrWUDzhzIz-OEERkcNzUA.png)


事實上，Stage是所有Layer合併\(compose\)之後的結果，如果用數位繪畫來類比，例如Photoshop或是Procreate，Layer就像是圖層，Stage就是畫面上的結果圖片，可以想像成是若將所有Layer壓扁成一層之後，那就是Stage。

換言之，Stage也有點像是Blender中Scene的概念，Scene中有mesh, light, material等物件，Stage中這些物件統稱為Prim，類型有World、Cube、Box、Light等，全部都是prim，而不同的類型會稱之為Scheme，其中， _"World"_ 這個Prim的Scheme是Xform\(Transformation\)， _"Cube"_ 的Scheme是Mesh， _"Box"_ 的Scheme是Cube。

此時，我們可以去進一步去檢視Layer中兩個World，可以發現他們的prim path是完全相同的


![](/assets/be14a4a5704f/1*yFzk50WVLnRCe9qtp4zGww.png)



![](/assets/be14a4a5704f/1*Kdh3qjkMI551Y5-ewD6w5A.png)


因此，將它們compose的成一個Stage時，他們會被視為同一個Prim，就像在兩個圖層中相同的位置一樣，壓扁合併後上面的圖層會去覆蓋掉下面的圖層，相同位置的內容會混和，同理，Stage也是相似的邏輯，兩個 _"world"_ 會compose，有衝突的部分以上層優先，也就是以 _Layout\.usda_ 為主，但是沒有衝突的部分就會同時存在，這就會產生Stage中所看到的結果。

這樣的關係的確就像是圖層，因此在Omniverse，或者說在OpenUSD的Application中，每一個\.usd都會import到App中轉變成一層Layer，當前開啟的\.usd的Layer稱之為Root Layer，其下還會有Sub\-layer，並且動態的compose成stage。


![](/assets/be14a4a5704f/0*RkAzYlivlc6Jt3SY)



[![](https://miro.medium.com/v2/da:true/resize:fit:1200/0*MfX_Sm2AVS_RGUB1)](https://medium.com/@nvidiaomniverse/what-you-need-to-know-about-universal-scene-description-from-one-of-its-founding-developers-12625e99389a){:target="_blank"}


因此，Stage會比Scene的概念更複雜一些，官方稱其為Scenegraph，因為Stage是多個layer composition動態計算出來的結果，也就是多個\.usd合併的結果，只要某個Layer中的Prim有了變化，就會重新計算出一個Stage，這個Prim與Prim之間的連結、檔案跟檔案之間的連結形成了Graph。

相對於動態的Stage來說，靜態的Scene也是多個檔案合併的結果，但是會捨棄掉所有的連結關係，因此就算其他檔案有了變化，也不會影響到Scene，如果要產生Scene那就得將所有更動重新export和import。

讓我從其他角度類比，靜態的Scene就像是數位繪畫時不使用圖層功能，所有的改動都在同一個圖層，因此所有的改動都會覆蓋掉過去的改動，動態的Scene則像是每個將個別的效果放置在不同的圖層，但是畫面上顯示的是所有圖層blend的結果。


![[https://www\.youtube\.com/watch?v=SaBXE4yQetk](https://www.youtube.com/watch?v=SaBXE4yQetk){:target="_blank"}](/assets/be14a4a5704f/1*yMi85V5xbd8Qlk-NhyRwlQ.png)

[https://www\.youtube\.com/watch?v=SaBXE4yQetk](https://www.youtube.com/watch?v=SaBXE4yQetk){:target="_blank"}

若從程式開發的觀點來看，靜態的Scene就像是用單純的使用zip去版本控制，source code每一次都是完整的保存，但是難以追溯每一個prim是從哪裡來的，也會將保存大量重複、過期的prim，一個常見的情況就是final\.zip、final\_final\.zip、final\_final\_final\.zip這樣版本控制。

動態的Stage就像是使用Git去版本控制，每個檔案的改動就會commit並merge，每個負責人都可以獨立作業，相同的功能也就只儲存在對應的單一檔案中，舉例來說， _Layout\.usda_ 只儲存 _MyModel\.usda_ 的Sub\-layer關係，但是 _"Box"_ 的細節則由另一個檔案去儲存，這樣 _Layout\.usda_ 雖然有使用到 _"Box"_ ，但是不需要儲存 _”Box”_ 的所有細節，只需要儲存連結關係，如此也可以避免類似Duplicate code\(重複程式碼\)的問題。


![[https://zhiminzhan\.medium\.com/10\-minutes\-guide\-to\-git\-version\-control\-for\-testers\-f58e059bb5e7](https://zhiminzhan.medium.com/10-minutes-guide-to-git-version-control-for-testers-f58e059bb5e7){:target="_blank"}](/assets/be14a4a5704f/0*x0QyIs5qFv9VSh9B.png)

[https://zhiminzhan\.medium\.com/10\-minutes\-guide\-to\-git\-version\-control\-for\-testers\-f58e059bb5e7](https://zhiminzhan.medium.com/10-minutes-guide-to-git-version-control-for-testers-f58e059bb5e7){:target="_blank"}

此時，Repository就有點類似全部的Layers，包含所有的\.usd，而Stage就像是pull下來的working folder，是解析完的資料、檔案。

靜態的Scene的好處是，所有的Prim都會存在一個檔案內一目了然，所有的改動都在相同檔案，不需要額外儲存關係，也只需要解析一次\(如果沒有發生改動的話\)，反之，動態的Stage則需要多花空間去儲存檔案的連結關係，也需要多花時間反覆計算結果，但好處在於，所有的prim只會同時存在一個地方、一個檔案中，每個檔案可以獨立改動。

換言之，如果沒有檔案之間的連結關係，就不再需要動態解析，一個靜態的Stage，完全可以說是一個Scene，但就是因為Scene跟Scene用Layer的方式動態合併，其中每個物件，也就是Prim彼此連結形成了Graph，因此Stage又稱為Scenegraph。


![[https://cganimator\.com/usd\-in\-3dsmax\-1\-export/](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}](/assets/be14a4a5704f/0*Md_CQfLydwhUTURe.jpg)

[https://cganimator\.com/usd\-in\-3dsmax\-1\-export/](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}

此外，Stage不僅僅是單純的將所有Prim集合到一起，Root layer仍然能夠改動所有的Prim，但是這些改動不會真的改動到Sub\-layer中的prim，也就是原始的prim仍然會保存，只是在解析Stage之時會將Root layer的Prim覆蓋掉Sub\-layer的prim\(如果有衝突的部分\)


> Enables non\-destructive editing, layering, and referencing 





因此，這樣的特性就稱之為 **non\-destructive editing** ，相對來看，如果是傳統的方法改動Scene，因為所有的prim都被整合到了單一的檔案中，因此所有的改動就會在這個單一的檔案中，因此只要改動的prim就不會保留原始的prim，同時因為我們理論上已經不知道這個prim是從那裡來的，就會造成不可逆的 **destructive editing** 。

換言之，Stage的好處就是所有的改動的上下游關係明確，彼此獨立，上游就下像是Sub\-layer，下游則是Root layer，上游的意思是Sub\-layer更接近流程上早期\(early stage\)的資料，也就是較下層的layer，下游則是流程上更後期的資料。


> OpenUSD Stage is the key to managing and interacting with 3D scenes 





總結來說，Stage不單純的是一個scene，而是管理多個scene的關鍵，因為我們可以想像窮盡每個sublayer到最底層，他們其實都是一個scene，因為它們沒有了連結關係，每一個scene可以用\.usd儲存，同時也可以成為sub\-layer被其他layer連結，因此這邊強調的是


> \.USD storing and exchanging 3D scene data \(mesh, camera, light, shader\) 





事實上，Blender的Scene格式\.blend就有類似的功能，例如\.blend可以link, append其他的\.blend，只是在模組化上沒有Omniverse，或者說OpenUSD做得那麼徹底，將所有物件、資料都可以封裝成Prim。

換言之，Modularity、Scalability在3D領域的重要性並不是現在才被強調，主要的原因在於隨著CG的進步，專案變得越來越複雜才能表現越來越優秀的畫面，這也就導致需要更多人的參與，也就增加了獨立作業的重要性。


> Ideal for complex projects involving multiple collaborators 





所以，OpenUSD的好處是任何改動都是往上疊加的，也就是各領域的專家會負責個別的Layer，越後期的改動會在越早期的改動之上，例如畫面的整體的風格調整會在場景的布局之上，就像是前面的數位繪畫的例子，濾鏡圖層應該會在線稿圖層之上。

若從coding的觀點，Modularity類似解耦合，Scalability像是SOLID原則中的Open\-Closed Principle，所有的後續的改動都是擴充，而不會修改到原有的code，這些都是隨著專案越來越複雜，降低修改成本的方式。

同理，OpenUSD這個做的目的就是減少CG流程上修改的成本，因為傳統的流程只要有改動，就需要大量反覆的使用不同的DCC\( [Digital Content Creation](https://openusd.org/release/usd_products.html){:target="_blank"} \)export, import各種檔案格式，這樣的成本會隨著規模指數上升，因為只要有其中一個點變化就有可能重啟整個流程，更糟的是，在重啟流程的時候又有了新的改動，這會導致災難性的版本控制、場景一致性，OpenUSD就是想解決這樣的問題，而Omniverse就是NVIDIA提出基於\.usd的DCC。

[**Products Using USD — Universal Scene Description 24\.08 documentation**](https://openusd.org/release/usd_products.html#blender-foundation){:target="_blank"} 
[_USD has support in many 3D Content Creation Applications and Ecosystems\. This list is maintained by the community, and…_ openusd\.org](https://openusd.org/release/usd_products.html#blender-foundation){:target="_blank"}

接著，我們來正式的深入談談Stage中重要的組成，Prim


> Used to build and manage 3D scenes\. Facilitate data encapsulation and sharing\. 





Prim就是Layer中的基本單位，舉凡imaginable的Mesh, Xform或者是imaginable的material, shader, animation，都可以是一個Prim，就拿原本的MyModel\.usda舉例好了
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

這個Layer對應到Stage就是三種Prim: Scope, Xform, Cube，從coding的角度理解就是class，這邊宣告出了三個prim，變數名稱分別是 _Geometry、GroupTransform、Box_ ，但實際上完整的變數名稱我們會稱之為Prim Path，我們可以在Omniverse打開 _MyModel\.usda_ ，從其中的Property中看到


![](/assets/be14a4a5704f/1*VUK4R8nFC76anZYwvHFsCw.png)



![](/assets/be14a4a5704f/1*7kuavv0dxfgtT9Zoro8C_w.png)



![](/assets/be14a4a5704f/1*yH5n3Tzhm7jr-wZLFLtOlA.png)


這樣就可以理解為什麼不同Layer但同名的Prim會合併，因為他們的完整的變數名稱相同，但是如果完整的Prim path不同時，那就會在Stage中分別存在。

那接著就要解釋Prim的Property，選擇 _"Box"_ ，然後點擊Property中的 _Add Transformation_ ，並且保存檔案。


![](/assets/be14a4a5704f/1*ppimN93aDGq3LL1VYT06DA.png)



![](/assets/be14a4a5704f/1*mb-yKz2lSzFRalmGcDHB7g.png)


可以發現 _MyModel\.usda_ 變成如下，可以發現Omniverse增加了許多資料，檔案上半部分屬於Omniverse自己需要的Custom Layer資料，也就是這個檔案作為layer的時候需要輔助的資料，這部份我們先省略跳過。
```python
#usda 1.0
(
    customLayerData = {
        # ...
    }
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double3 xformOp:rotateXYZ = (0, 0, 0)
            double3 xformOp:scale = (1, 1, 1)
            double3 xformOp:translate = (0, 0, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
        }
    }
}
```

我們要關注的是 _"Box"_ 中發生的變化，多出了四行，分別是常見的三種Transformation，還有operate的順序，這邊有兩件事

第一，Transformation之所以放在介面中的Property這個Tab中，正是因為Transformation的確就是Property的一種，更準確來說，Prim的內容，也就是 _def_ 中的內容，例如這四行都屬於Property。
```python
double3 xformOp:rotateXYZ = (0, 0, 0)
double3 xformOp:scale = (1, 1, 1)
double3 xformOp:translate = (0, 0, 0)
uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:rotateXYZ", "xformOp:scale"]
```

第二，Transform不一定存在Xform這種類型的Prim之中，原則上，一個prim中有什麼Property基本上都可以，因此Cube可以有Transform的Property，因為class中要有什麼樣的變數基本上都可以。

但是通常會有一些常見的規則，例如Omniverse中不同種類的Prim都會有些預設的欄位，比較明顯的是Scope，因為是最輕量化的Prim，不存有任何實質的幾何或是設定，主要功能就是把不同的Prim整合到不同的Scope中，有點類似資料夾的功能，官方是用Container一詞去描述Scope裝有不同的Prim這樣的概念。因此在Omniverse中Scope的Property欄位中並沒有 _Add Transformation_ ，甚至你可以把Scope當作是不能transform的Xform，換言之，Scope只是為了確立hierarchy存在，是一個最輕量創造父子階層的Prim。

事實上，如果參照OpenUSD的官網可以發現Property又分成兩類，分別是Attribute以及Relationship


![[https://openusd\.org/release/api/class\_usd\_property\.html](https://openusd.org/release/api/class_usd_property.html){:target="_blank"}](/assets/be14a4a5704f/0*QyiSyZN-ba1HLSVL.png)

[https://openusd\.org/release/api/class\_usd\_property\.html](https://openusd.org/release/api/class_usd_property.html){:target="_blank"}

基本上Prim中絕大多數的data都是Attribute，基本上一個名稱跟value就是一個Attribute，而relationship則是value存的是一個路徑，常使用於Material，可透過Omniverse下方的Material Tab隨便下載一個material，然後在Box中選擇該Material，並且儲存。


![](/assets/be14a4a5704f/1*rPqoah0UmPDNgzMedxOCIA.png)


之後我們可以觀察 _MyModel\.usda_ 的變化，一樣，我們省略 _"Box"_ 以外的變化，多出來的部分就是relationship。
```python
rel material:binding = </World/Looks/Carbon_Fiber_ANI_01> (
                bindMaterialAs = "weakerThanDescendants"
            )
```

另外值得一提的是Primvars，是Attribute的一種，全稱是Primitive Variable，你可以在Property中找到，可以把它當作是每個Vertex上帶有的資料，也可以延伸到每個Face帶有的資料，主要就是給Shader使用的，可以想像這些資料後續會包成VBO，再拿給Shader render。

重點是，Prim中含有許多Property，更一般化的來說Prim可以把一堆相關的資料封裝起來，因此Mesh, Light等等都可以用Prim來表示，因為Prim可以隨意的放入各種客製化的參數。


> A core component that acts as a container for data and attributes in a scene\. 




### 結論

本篇大致簡介了在Omniverse Kit中一些簡單的介面互動，並且與\.usd檔的互動，還有一些基本的名詞解釋，你可以發現，Omniverse Kit一定程度上不過是一個用來修改\.usd的圖形化介面，因此我在開頭才會寫到， **與其說Omniverse是可以輸入輸出\.usd檔案的軟體，不如說，Omniverse是基於OpenUSD的軟體。**

甚至NVIDIA也在今年的 [SIGGRAPH 2024](https://www.nvidia.com/gtc/sessions/openusd-day/){:target="_blank"} 與 [SIGGRAPH Asia 2024](https://asia.siggraph.org/2024/session/?sess=sess410){:target="_blank"} 都有一系列活動在推廣OpenUSD，而不是Omniverse，比較容易理解的原因是，他們也希望其他的DCC可以加入一起支援\.usd檔的輸入輸出，甚至是同步，這樣所有的數位資產就能夠沒有隔閡的傳輸，換言之，OpenUSD並不專屬於Omniverse，更準確來說，Omniverse Kit只是支援OpenUSD其中的一個應用，只是NVIDIA提供給所有人的其中一種OpenUSD方案。


[![What is the USD File Type? | Getting Started in NVIDIA Omniverse](/assets/be14a4a5704f/4aab_hqdefault.jpg "What is the USD File Type? | Getting Started in NVIDIA Omniverse")](https://www.youtube.com/watch?v=GOdyx-oSs2M){:target="_blank"}


在了解到Omniverse與OpenUSD的關係後，接著我們將繼續參照Learning Path繼續探索Omniverse Kit。


[![](https://forums.leadtek.com/images/Leadtek_AI-Forum.jpg)](https://forums.leadtek.com/tw/post/3387){:target="_blank"}


[**OpenUSD 嘿溜**](https://www.zhihu.com/column/c_1689606249291915265){:target="_blank"} 
[_NVIDIA、痪科坏析烛的OpenUSD格式是嘁犯_ www\.zhihu\.com](https://www.zhihu.com/column/c_1689606249291915265){:target="_blank"}

[**USD in 3dsMax \#1 \- Export**](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"} 
[_USD for 3dsMAx 0\.5 has been released\. You can see how it has progressed in the What's new section of the official…_ cganimator\.com](https://cganimator.com/usd-in-3dsmax-1-export/){:target="_blank"}


[![](https://static.wixstatic.com/media/b46d06_64a0f861ad0744fea6c47de8e459ed41~mv2.png/v1/fill/w_682,h_511,al_c,lg_1,q_85/b46d06_64a0f861ad0744fea6c47de8e459ed41~mv2.png)](https://www.ireneortegasanz.com/post/master-the-usd-system-the-keys-to-use-it-in-the-layout-department){:target="_blank"}


[**Layers — Omniverse Extensions**](https://docs.omniverse.nvidia.com/extensions/latest/ext_core/ext_layers.html){:target="_blank"} 
[_The Layers Extension provides a convenient way to organize and manage your scene while also providing a comprehensive…_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/extensions/latest/ext_core/ext_layers.html){:target="_blank"}

[**Overview — Omniverse Kit 1\.8\.1 documentation**](https://docs.omniverse.nvidia.com/kit/docs/omni.kit.widget.layers/latest/Overview.html){:target="_blank"} 
[_Edit description_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/kit/docs/omni.kit.widget.layers/latest/Overview.html){:target="_blank"}

[**Usd Survival Guide**](https://lucascheller.github.io/VFX-UsdSurvivalGuide/pages/core/elements/property.html#relationshipOverview){:target="_blank"} 
[_This repository holds the docs and examples for the Usd Survival Guide\._ lucascheller\.github\.io](https://lucascheller.github.io/VFX-UsdSurvivalGuide/pages/core/elements/property.html#relationshipOverview){:target="_blank"}


[![](https://aousd.org/wp-content/uploads/sites/28/2023/10/nv-AOUSD-Schematic-blog-social-blog-1280x720-16x9-1-2.png)](https://aousd.org/blog/explainer-series-what-is-openusd/){:target="_blank"}


[**Composition Details Panel \- Omniverse USD**](https://docs.omniverse.nvidia.com/usd/latest/usdview/panel_composition.html){:target="_blank"} 
[_The Value tab shows the value of the selected property\. The property selection comes from the Properties Panel …_ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/usd/latest/usdview/panel_composition.html){:target="_blank"}

[**Content Reuse \- Omniverse USD**](https://docs-prod.omniverse.nvidia.com/usd/latest/learn-openusd/independent/modularity-guide/content-reuse.html){:target="_blank"} 
[_The concepts of reuse and instancing are very closely related\. Understanding reuse and modularity is a important before…_ docs\-prod\.omniverse\.nvidia\.com](https://docs-prod.omniverse.nvidia.com/usd/latest/learn-openusd/independent/modularity-guide/content-reuse.html){:target="_blank"}

感謝你的閱讀，如果你對我的文章對你有所幫助或是意見歡迎回覆，如果你想要支持我可以：
- 拍個手👋，或是分享一些想法💬
- [追蹤我的頁面](https://medium.com/@maochinn){:target="_blank"}
- [訂閱我的專欄](https://medium.com/maochinn){:target="_blank"}
- [透過LinkedIn聯繫我](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


或是觀看我其他系列文章
- [【Omniverse】學習筆記 — 00：Kit\-based Development](../a54ae65f22bf/)
- [【Omniverse】學習筆記 — 01：Application and Extension](../e765192086c8/)
- [【Omniverse】學習筆記 — 02：Kit Workshop SIGGRAPH 2022](../2183284ed751/)



_[Post](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
