---
title: "【Omniverse】Development 102: Working With Prims and Default Schemas"
author: "帽捲"
date: 2024-12-26T10:26:11.390+0000
last_modified_at: 2024-12-26T10:32:51.162+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","openusd"]
description: "In 【Omniverse】Development 102: Learning OpenUSD, the general concept of OpenUSD is roughly explained, including how to simply edit the…"
image:
  path: /assets/5732179f7159/1*ZNTTdHU9QTqtD5d24buh_w.png
render_with_liquid: false
---

### 【Omniverse】Development 102: Working With Prims and Default Schemas

中文版本： [【Omniverse】學習筆記 — 04：Prims and Schemas](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-04-working-with-prims-and-default-schemas-8a5581d9ef78?source=---------0-----------------------){:target="_blank"}

In [【Omniverse】Development 102: Learning OpenUSD](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5?source=---------1-----------------------){:target="_blank"} , the general concept of OpenUSD is roughly explained, including how to simply edit the \.usd file and interact with and view it through the Omniverse App\. Let’s go over the content quickly\.
In an app based on OpenUSD, for example, Omniverse, \.usd can all correspond to a layer\. At the same time, Omniverse will instantly compose multiple layers into a stage, and the layers contain various **prims** , among which, The type of Prim is called **Schema** , such as meshes and lights\.
### Learn OpenUSD: Working With Prims and Default Schemas

The recording method of this article is the same as before\. The scope of the record is roughly around this course, but the operation uses the Composer built by Omniverse Kit, so the operations that are more difficult to do in Omniverse will be skipped first\.

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-20+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-20+V1){:target="_blank"}

Let’s use the [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} file to discuss in depth\. First create the file in VS Code and then let Composer read the file\.
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

This file defines three prims, and also defines their hierarchy, but you can notice that there are three words when defining a prim, for example: `def Cube "Box"` , which are **Specifiers, Schema and Name\.**
#### Specifiers

There are three types of Specifiers, namely `def` , `over` and `class` \. `def` can be seen in most \.usds, especially the closer to the lower layer, that is, the more upstream the original file in the process, because it is defining a new one from scratch\. Specifiers that need to be used when priming\.


> Specifier class 





Instead of defining an prim, you can also use `class` to define an abstract prim\. This concept is similar to the class in coding\. You can define a **blueprint or template** \.

For example, you can change _MyModel\.usda_ to this
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            inherits = [
                </_box>
            ]
        )
        {
        }
    }
}
class "_box" (
    )
{
    double size = 4
}
```

Returning to Omniverse, you can find that there is an extra "\_box" in Layer\. This "\_box" does not have an entity, so you cannot find it from the viewport\. At the same time, you can notice its attribute `size` , which is the Raw USD Properties in Figure 1\(a\) \. `size=4` \. At the same time, because prim `"Box"` inherits class `"_box"` , it will overwrite the default `size` , so the Cube in the screen becomes larger\.


![](/assets/5732179f7159/1*ZNTTdHU9QTqtD5d24buh_w.png)



![Figure 1: \(a\) Class “\_box”; \(b\) Prim “Box”](/assets/5732179f7159/1*WQ4LbeJ9W5j59ImFTacuDA.png)

Figure 1: \(a\) Class “\_box”; \(b\) Prim “Box”

At this point, we can try some interesting operations, such as changing `def Cube "Box"` to `def "Box"` \. The result is shown in Figure 2\(a\) \. It can be found that `"Box"` is just an instance of `"_box"` , and at the same time The box in the viewport should also be gone, because `"Box"` is no longer a cube\.

`"Box"` just has an attributesize prim at this time\. \(If the box still exists in the viewport, try re\-reading _MyModel\.usda_ \)


![](/assets/5732179f7159/1*gZ0VHSp7WM2MoUlJPHsdPw.png)



![Figure 2: \(a\) After changing `def Cube "Box"` to `def "Box"` ; \(b\) After changing `class "_box"` to `class Cube "_box"`](/assets/5732179f7159/1*iEFUzeTfwG_HIh3QirOivQ.png)

Figure 2: \(a\) After changing `def Cube "Box"` to `def "Box"` ; \(b\) After changing `class "_box"` to `class Cube "_box"`

At this time, if you want to re\-display `"Box"` as a box in the viewport, in addition to the original method of `def Cube "Box"` , a more reasonable method is `class Cube "_box"` \. The defined class itself is a type of Cube , because `"_box"` is a Cube at this time, the inheritor `"Box"` will naturally be a Cube, and the result is shown in Figure 2\(b\) \.

At the same time, we can add some **local opinions** to `"Box"` , that is, a new attribute\. This attribute will overwrite the `"_box"` the value of the attribute\. In OpenUSD, we will call the value of the attribute in different \.usd corresponding to the layer\. **opinion** \.
```python
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def "Box" (
            inherits = [
                </_box>
            ]
        )
        {
            double size = 1
        }
    }
}
class Cube "_box" (
    )
{
    double size = 4
}
```

As a result, the screen looks like it has returned to its original state, a Cube with size = 1\.


> Specifier over\(ride\) 





But whether it is `def` or `class` , they will be affected by over Specifier\. Its function is somewhat similar to what was done when I just mentioned the opinion\. You can use `over` in the upper layer to override the opinion in the lower layer\. In other words, `over` often appears in files with multiple files\. situation\.

Therefore, we use the same _Layout\.usda_ as in the previous article as an example\. In it, we add these lines
```python
over "Geometry"
{
    over "GroupTransform"
    {
        over "Box" 
        {
            double size = 10
        }
    }
}
```

After that, after opening _Layout\.usda_ with Omniverse, you can find that the `size` of `"Box"` changes to 10, as shown in Figure 3\(a\), because _Layout\.usda_ is the root layer at this time, and its value is the local opionion, and the opinion of _MyModel_ \.usda will be overwritten by `over` \.


![](/assets/5732179f7159/1*-3CE-E4WATOO2DdrdTS0vg.png)



![Figure 3: \(a\) After overriding opinion of “ _/Geometry/GroupTransform/Box”; \(b\) After overriding_ opinion of _“/Box”_](/assets/5732179f7159/1*bPhVl8QE1hRQL4hlMJuEOg.png)

Figure 3: \(a\) After overriding opinion of “ _/Geometry/GroupTransform/Box”; \(b\) After overriding_ opinion of _“/Box”_

A small thing to note here is that if _Layout\.usda_ omits other prims and only writes
```cpp
over "Box" 
{
    double size = 10
}
```

The result is shown in Figure 3\(b\) \. A new Prim will be defined in the outer layer\. Although the name is also `"box"` , the paths of the two boxes are different, they are
- _/Geometry/GroupTransform/Box_
- _/Box_


Each Prim has a unique Path\. In other words, as long as **the Path is different, it is a different Prim** \. As long as the Path is the same, it will be regarded as the same prim, and **Compose** will be involved, such as overriding\.

Then if you write like this in _Layout\.usda_
```python
over "_box" 
{
    double size = 10
}
```

The result is shown in Figure 4\(a\) \. We override the opinion of class `"_box"` in Layout\.usda, but in the property we will find that the `size` of `"Box"` is still 1, because this opinion comes from the inherited opinion, and The local opinion of `"Box"` is still stronger than it, even if this inherited opinion comes from the upper layer\.


![](/assets/5732179f7159/1*v-PlnvIWTlY1MSHkz240BQ.png)



![Figure 4: \(a\) After overriding opinion of class “\_box” ; \(b\) Removing local opinion of prim “Box”](/assets/5732179f7159/1*qLrTms4UcB84Ouel04IFGQ.png)

Figure 4: \(a\) After overriding opinion of class “\_box” ; \(b\) Removing local opinion of prim “Box”

Therefore, if you want to change the `size` of `"Box"` to 10, you need to remove the local opinions of `"Box"` \. At this time, the `size` of `"Box"` is completely determined by `"_box"` \. The modified _MyModel\.usda_ is as follows shown, the result is shown in Figure 4\(b\) \.
```cpp
#usda 1.0

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def "Box" (
            inherits = [
                </_box>
            ]
        )
        {
        }
    }
}
class Cube "_box" (
    )
{
    double size = 4
}
```

Or as shown in Figure 3\(a\), you need to override the `"Box"` opinion directly on the upper layer\.

According to the above, it can be found that the opinion will become more complicated as the number of \.usd files increases, because when the compose layers become stages, it will be necessary to decide whose opinion is stronger\. The details are beyond the content of this article and will be explained in detail in subsequent articles\.
#### Schema

The concept is similar to the **class** just mentioned, and it can also be regarded as a **template** \. For example, the Schema of prim “Box” in `def Cube "Box"` is **Cube** \. Conceptually, `"Box"` is defined as a Cube\. As for the definition of Cube, it is determined in advance\. 
It is standardized common types, **you can completely imagine that Schema is a built\-in class\.** You don’t need to inherit but just use it directly\. This can explain why you can write `class Cube "_box"` \. In fact, it is `"_box"` Inherits the built\-in class `Cube` \.

You can imagine that if `Cube` is written as Class, it can be expressed like this
```cpp
class Cube "Cube" (
 
    inherits = </Gprim>
 
) {
 
    double size = 1.0
    float3[] extent = [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)] 
 
}
```

Of course, it’s not just that simple\. Not only should the `Cube` have more attributes, but also how to interpret these attributes\. For example, when the `size` changes to 10, what changes should be made to the Cube’s geometry\.

In fact, Schema is divided into two major categories, IsA and API\. `Cube` belongs to the former IsA Schema\.
#### IsA Schema

It is also called **Typed schema or Prim schema** , which means that this schema is used to define the Type of a Prim\. Furthermore, Cube is an **concrete IsA Schema** , that is, the `typeName` of `Cube` can be used directly\. Instantiate prim\. 
On the contrary, **Abstract \(non\-concrete\) IsA Schema** is often used as a basis for internal development\. Although it has a `typeName` , it cannot be instantiated directly, for example: `UsdGeomImageable` \.
#### API Schema

Compared with IsA, API Schema is not used for instantiation, so naturally it is **Abstract** and has no typeName\. 
Just like prim uses IsA Schema to formulate the format, then **API Schema is used to formulate the function format** \. API Schema is open to **A unified specification** used by different developers, IsA Schema is more like a specification used by assets between creators\.

API Schema only needs to formulate the API, so **it may lack implementation** and needs to be implemented by real developers according to their own needs\. Therefore, this part of the format is biased towards development and coding, and it is not easy to see too much on the Omniverse interface\. There are clues, so I’ll skip this part for now\.


[![](https://aousd.org/wp-content/uploads/sites/28/2024/04/AOUSD-schemas-blog.gif)](https://aousd.org/blog/explainer-series-for-developers-what-are-openusd-schemas/){:target="_blank"}


All in all, Schema is the formulation of format, or **data modeling** , whether it is prim or function\. We can further think about an interesting question, what is the difference between IsA Schema and class specifier, because I just mentioned


> **You can completely imagine that Schema is a built\-in class\.** 




First of all, both can formulate prim templates, but the latter cannot further affect other data based on pre\-written rules\.
You can imagine that **Schema** is the most basic type of prim\. All formats and behaviors of this prim are clearly defined in advance, including what this prim looks like\. For example, the geometry of Cube is composed of 8 vertices, and when rendering, it is 12 triangles

**Class** is an expansion based on these basic prims, such as the color of this Cube\. Of course, color can also be specified in IsA Schema\. Developers designing Cube need to consider whether color is a necessary attribute of Cube\. Relatively speaking, the advantage of **Class specifier** is that it is quite easy to use, but it can only customize some simple attributes\. However, how to use these attributes requires subsequent development\.

However, Schema is not necessary\. For example, `def "Box"` is legal\. It defines the simplest prim\. The Property reflected in Omniverse is only Raw USD Properties, such as Figure 2\.a\. But if you `def Cube "Box"` or `class Cube "_box"` , you can find that the Property has other attributes, such as **Geometry and Visual** \. The specifications of these formats come from the Cube Schema\. For the former, please refer to Figure 1\(b\), for the latter, please refer to Figure 2\(b\)

In addition, it can be added that there is a section of `defaultPrim = "World"` in _Layout\.usda_ \. This line is the entry point of the referrer when this file is **referenced** or **preload** \. These two mechanisms will be introduced later\.
```python
#usda 1.0
(
    customLayerData = {
        # ...
    }
    defaultPrim = "World"

    subLayers = [
        @./MyModel.usda@
    ]
)
```

Here is an introduction to some terms of OpenUSD, including Houdini and Maya

[**USD Terms and Concepts — Universal Scene Description 24\.11 documentation**](https://openusd.org/release/glossary.html){:target="_blank"} 
[_USD introduces quite a few terms and concepts, some of which, unavoidably, already have different meanings in other…_ openusd\.org](https://openusd.org/release/glossary.html){:target="_blank"}

[**USD Basics**](https://www.sidefx.com/docs/houdini/solaris/usd.html){:target="_blank"} 
[_USD is a system of software and file formats for describing 3D scenes by composing layers\. For example, a master USD…_ www\.sidefx\.com](https://www.sidefx.com/docs/houdini/solaris/usd.html){:target="_blank"}

[**Help**](https://help.autodesk.com/view/MAYAUL/2024/ENU/?guid=GUID-772B376F-4E86-4847-A1A0-BB84E21DB2FD){:target="_blank"} 
[_Edit description_ help\.autodesk\.com](https://help.autodesk.com/view/MAYAUL/2024/ENU/?guid=GUID-772B376F-4E86-4847-A1A0-BB84E21DB2FD){:target="_blank"}

Thank you for reading\! If you found my article helpful or have any feedback, feel free to reply\. If you’d like to support me, you can:
- Clap 👏 or share your thoughts 💬
- [Follow me on Medium](https://medium.com/@maochinn){:target="_blank"}
- [Subscribe to me on Medium](https://medium.com/maochinn){:target="_blank"}
- [Connect with me on LinkedIn](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


You can also check out my other series of articles:
- [【Omniverse】Development 101: Getting Started with Kit\-Based Development](../78f8915183be/)
- [【Omniverse】Development 101: Understanding Applications and Extensions](../1d990d98b7f9/)
- [【Omniverse】Development 102: Learning OpenUSD](https://medium.com/maochinn/omniverse-development-102-openusd-59dee6c16bd5?source=---------1-----------------------){:target="_blank"}



_[Post](https://medium.com/maochinn/omniverse-development-102-working-with-prims-and-default-schemas-5732179f7159){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
