---
title: "【Omniverse】學習筆記 — 05：Property and Metadata"
author: "帽捲"
date: 2025-02-05T15:28:12.261+0000
last_modified_at: 2025-02-27T07:22:15.106+0000
categories: ["Maochinn"]
tags: ["nvidia","omniverse","openusd"]
description: "在【Omniverse】學習筆記 — 04：Prims and Schemas中我們學到如何直接v修改.usd的內容來增加和修改layer中的prim，本篇將會在Omniverse內建的Script Editor中，使用OpenUSD…"
image:
  path: /assets/a7fa6a26a49a/1*ICKb_BFwpmxz-bRXHJp-zw.png
render_with_liquid: false
---

### 【Omniverse】學習筆記 — 05：Property and Metadata

English Version: [【Omniverse】Development 102: Scripting Properties and Metadata](../b8e7a81710ee/)

在 [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/) 中我們學到如何直接修改\.usd的內容來增加和修改layer中的prim，本篇將會在Omniverse內建的Script Editor中，使用OpenUSD API來與prim乃至於stage中所有資料互動，你可以理解為透過Python Script來修改\.usda檔案，而不是像我們過去一樣是手動修改內容。
#### 目錄
- Learn OpenUSD: Using Attributes
- Learn OpenUSD: Understanding Model Kinds
- Learn OpenUSD: Traversing Stages


要在Omniverse中使用Script Editor，比較方便的方式是透過debug模式來啟動，詳細可以參考 [【Omniverse】學習筆記 — 00：Kit\-based Development](../a54ae65f22bf/)
```bash
.\repo.bat launch -d
```

無論是Composer還是Editor，啟動後可以在Developer>Script Editor中找到


![Figure 1: Developer > Script Editor](/assets/a7fa6a26a49a/1*t-Vq5nGdmoOFK10jSxmkZQ.png)

Figure 1: Developer > Script Editor

Script Editor打開後如左圖，它可以讓你快速嘗試一些API的功能，當然，你也可以自己創建一個extension來測試API，這個時候可以使用VS Code Link，讓你能夠trace到底層，但本篇只需要使用Script Editor即可。


![Figure 2: Script Editor](/assets/a7fa6a26a49a/1*tKA1MMTsIMc1h01QSXQtbw.png)

Figure 2: Script Editor
### Learn OpenUSD: Using Attributes

課程中主要談及如何使用OpenUSD API來set/get prim的attribute，舉例來說就像是 [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/) 中 `Cube` 的 `size` ，當然我們可以透過直接人工修改\.usda來達成，不過我們也能透過script來自動化的運作。

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-19+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-19+V1){:target="_blank"}

我們可以先利用OpenUSD Python API來創建prim來小試身手，首先手動把整個stage中的所有prim清空，然後在Script Editor輸入以下script，接著按下Run，如Figure 2的左下角
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()

scope = UsdGeom.Scope.Define(stage, "/Geometry")
xform = UsdGeom.Xform.Define(stage, scope.GetPath().AppendChild("GroupTransform"))
cube = UsdGeom.Cube.Define(stage, xform.GetPath().AppendChild("Box"))
```

應該可以看到整個stage的結果就像是 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#bf67){:target="_blank"} 打開的結果，我們可以將其存成另一個\.usda，並且比對一下。


![](/assets/a7fa6a26a49a/1*ICKb_BFwpmxz-bRXHJp-zw.png)


結果的大概像是下面的內容，就像是把 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 放進Omniverse再儲存一樣，可以參考之前的 [結果](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#bf67){:target="_blank"} ，上面會有一大堆Omniverse產生出來的設定。
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
        }
    }
}
```

以此我們大概對於使用OpenUSD API有一個初步的認識，我們可以手動建立\.usd，也可以透過API建立\.usd，同時，既然我們可以手動修改prim的data，就像 [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/) 中做到的，我們自然也可以透過API做到類似的事情，首先，我們從Property的Attributes開始。
#### Attributes

事實上，prim中的”real data”分成兩類，Property and Metadata。

其中Attributes屬於Property，就如同在 [【Omniverse】學習筆記 — 03：OpenUSD中](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#7738){:target="_blank"} 提到的，那麼這邊一樣使用祖傳的 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 來舉例，在裡頭增加一個簡單的Attributes，就跟 [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/) 中做的事情類似，增加一個型態是 `double` 的 `size` ，複製下面的腳本到Script Editor並且Run。
```css
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()

scope = UsdGeom.Scope.Define(stage, "/Geometry")
xform = UsdGeom.Xform.Define(stage, scope.GetPath().AppendChild("GroupTransform"))
cube = UsdGeom.Cube.Define(stage, xform.GetPath().AppendChild("Box"))

size_attr = cube.GetPrim().CreateAttribute("size", Sdf.ValueTypeNames.Double)
size_attr.Set(1.0)
```

結果應該會看到 `"Box"` 變大了，儲存後結果如下
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double size = 4
        }
    }
}
```

基本上就做一跟之前一樣簡單的事情。同時，可以發現一件事情，腳本的前半段是在define prim，後半段在設定prim的attribute中的值，如果場景中已經有prim了，比較理想的做法是用get的
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

if box_prim:
    size_attr = box_prim.CreateAttribute("size", Sdf.ValueTypeNames.Double)
    size_attr.Set(1.0)
```

這樣script就單純多了，讓我們重新專注在修改attribute的部分，可以注意到我們設定value之前，必須要先創建，或者說是get到 `size` 這個attribute，才能進一步去設定。

這種作法非常直覺，你想創建任何的Attribute都可以，無論合法與否，換言之，如果你不小心名稱寫錯，比如寫成 `s1ze` ，他不會有任何報錯，但是畫面中的 `"Box"` 就是毫無反應，如果我們儲存後會發現
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            custom double s1ze = 4
        }
    }
}
```

此處可以注意到， `s1ze` 的確被創建了，但同時可以發現，在 `s1ze` 前面多了 `custom` ，意思就是這個attr是使用者自創的，沒有預設的用途，也就是Omniverse無法識別這個attr對應的功能，因此，比較推薦的做法還是透過 [IsA Schema](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-04-working-with-prims-and-default-schemas-8a5581d9ef78#1e4f){:target="_blank"}
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

if box_prim:
  cube = UsdGeom.Cube(box_prim)
  size_attr = cube.CreateSizeAttr()
  size_attr.Set(4.0)
```

更具體來說，是Cube Schema，因為 `"Box"` 就是一個Cube，所以首先我們要先將Box從一個單純的prim，轉換成 `UsdGeom.Cube` 這個schema架構下的prim，我們才能對 `"Box"` 使用 `UsdGeom.Cube` 這個schema中設計的方法，也就是 `CreateSizeAttr()` 。

因為Cube Schema中使用 `size` 這個attr的value來改變Cube的大小，因此Schema有提供 `CreateSizeAttr()` 這個方法，來幫我們建立對應的attr，整個過程我們不需要知道正確的attr名稱，只需要使用API就能確保我們能夠創建正確的Attr。

用Schema提供的方法好處除了名稱不會寫錯，另外就是比較有可讀性，當然還有其他好處，後面更複雜的例子可以說明。總之，理論上兩者做法都可以，但可以注意到，這邊我們是先創建了attribute，才去設定值，反之，如果我們要取得value，也要先取得attribute才能再取得value。
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

if box_prim:
  cube = UsdGeom.Cube(box_prim)
  size_attr = cube.CreateSizeAttr()
  size_attr.Set(4.0)

  # Get the size, display color, and extent attributes of the cube
  cube_size: Usd.Attribute = cube.GetSizeAttr()
  print(f"Size: {cube_size.Get()}")
```

之後，下一個稍微複雜的操作，將 `"Box"` 移動到特定的位置，換言之，就是設定Translate，或者更精確地來說，是設定Transformation中的Translate。依樣照葫蘆的做法像是
```python
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

if box_prim:
  xformable = UsdGeom.Xformable(box_prim)
  translate_op = xformable.AddTranslateOp()
  translate_op.Set(Gf.Vec3f(1, 2, 3))
```

我們要將 `"Box"` 移動到\(1, 2, 3\)這個位置，可以利用 `UsdGeom.Xformable` 這個Schema，執行儲存後可以發現多出來的attr不只一項
```python
#usda 1.0
(
    customLayerData = {
        #...
    }
    #...
)

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box"
        {
            double3 xformOp:translate = (1, 2, 3)
            uniform token[] xformOpOrder = ["xformOp:translate"]
        }
    }
}
```

其實之前也看過類似的 [結果](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#bf67){:target="_blank"} 。 `xformOp:translate` 就是要設定的位置，除此之外還有 `xformOpOrder` ，簡單來說， `xformOp` 總共有三種Op，分別是scale, rotate and translate，三種Operator沒有交換律，因此order很重要，只要牽涉到transformation就必須具備 `xformOpOrder` 這個attr。

此時可以發現 [IsA Schema](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-04-working-with-prims-and-default-schemas-8a5581d9ef78#1e4f){:target="_blank"} 的優點，就算你不知道Attr確切的名稱或者連帶的Attr你也能夠正常的使用功能，雖然你仍需要知道function的名稱，但是打錯字會有錯誤提醒。當然，事情不總是這麼美好，在Python的API中要get `xformOp:translate` 就略顯囉嗦。
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
xformable = UsdGeom.Xformable(box_prim)
    
translate_op = None
for op in xformable.GetOrderedXformOps():
    if op.GetOpType() == UsdGeom.XformOp.TypeTranslate:
        translate_op = op
        break
    
if translate_op:
  translate_attr = translate_op.GetAttr()
  translate_value = translate_attr.Get()
  print(translate_value)
```

如果想要拿到translate確切的value，我們必須要先拿到所有的 `xformOp` ，然後再依據型態辨別出 `xformOp:translate` ，然後取得attribute，最後再拿到value。

當然，我們還是可以使用比較一般性的方法
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
xformable = UsdGeom.Xformable(box_prim)

if box_prim:
    translate_attr = prim.GetAttribute("xformOp:translate")
    translate_value = translate_attr.Get()
```

基本上可達到一模一樣的結果，如果你事先知道attr的運作方式，這種做法甚至較為方便，你可以透過 `GetAttribute` 直接拿到指定的attr，當然，如果你真的很懶可以直接透過 `CreatAttribute` 來直接創建一個新的去覆蓋掉舊的，然後直接呼叫get/set來做後續的操作。

總之，相較於手動修改\.usd，我們也可以撰寫腳本呼叫OpenUSD API，然後API的程式碼再去修改\.usd。

目前針對使用腳本修改Attr主要介紹了兩種方式，一種就是利用 [IsA Schema](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-04-working-with-prims-and-default-schemas-8a5581d9ef78#1e4f){:target="_blank"} ，例如 `UsdGeom.Cube` 以及 `UsdGeom.Xformable` 提供的方法來修改，另一種則是用直接使用 `Usd.Prim` 的方法來修改，也就是 `CreatAttribute()` 。前者雖然可能比較囉嗦，但好處在於，如果未來Schema的運作方式發生變化，例如Attr的名稱改變或是新增其他Attr時，我們不需要修改code，只要呼叫最新版本的方法即可，同時呼叫方法也讓code整體可讀性變高。後者的好處在於可以更直接的操作data，更接近於手動修改檔案，適合用在debug。

事實上，一樣以移動prim為例，是一個更精解的作法，也就是官方課程提供的做法
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

UsdGeom.XformCommonAPI(box_prim).SetTranslate(Gf.Vec3d(1, 2, 3))
```

這個方式就是在 [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/) 還有提到 [API Schema](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-04-working-with-prims-and-default-schemas-8a5581d9ef78#4fde){:target="_blank"} ，只需要一行即可，但這種方法通常只有常見功能會有API可以使用，同時，這也不免讓人覺得困惑，達成一樣的功能的方法有這麼多種，究竟要用哪種方法比較好？事實上，我剛剛列舉只是OpenUSD的方法，Omniverse kit也有自己的API可以做到類似的事情，因此這個問題超出本文範圍，之後再介紹。

總之，要增加、調整Attribute有很多手段，最根本的方法是直接修改\.usd，或是呼叫設計好的API來修改\.usd，這樣會避免很多人工上的失誤，當然你也可以透過Omniverse的介面來互動，但實際上背後也是呼叫API，相對的，如果你會使用API也可以做到一樣的事情，同時也能客製化的撰寫自己的腳本甚至介面上沒有的功能。

[**Universal Scene Description: UsdGeomXformable Class Reference**](https://openusd.org/dev/api/class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b){:target="_blank"} 
[_Base class for all transformable prims, which allows arbitrary sequences of component affine transformations to be…_ openusd\.org](https://openusd.org/dev/api/class_usd_geom_xformable.html#ad6dfc740dcec052482489647af9ed36b){:target="_blank"}
#### Relationship

Property中除了Attributes以外就是Relationship，一定程度上，你可以將Relationship當作是特殊的Attributes，只是它儲存的是pointer，他將指向stage中的prim，我們可以試著打開 [_Layout\.usda_](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#188a){:target="_blank"} 後執行腳本：
```css
from pxr import Usd, UsdGeom, Sdf, Gf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
world_prim = stage.GetPrimAtPath("/World")

custom_relationship: Usd.Relationship = box_prim.CreateRelationship("myCustomRelationship")
custom_relationship.SetTargets(["/World"])
```

我們在 `"Box"` 儲存一個relationship，裡頭儲存著 `"World"` 的位置，如果光從腳本上觀察，你甚至可以認為Relationship就是一個儲存string的Attributes，但是儲存後檢視 [_Layout\.usda_](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#188a){:target="_blank"} 查看差異
```python
#usda 1.0

#...

over "Geometry"
{
    over "GroupTransform"
    {
        over "Box"
        {
            rel myCustomRelationship = </World>

        }
    }
}
```

看起來就不像是單純的字串，事實上，relationship指向的是 **stage** 中特定prim，換言之，這個prim可能由不同的layer compose而成，不是特定layer或者說特定\.usd中的prim。

但是relationship本身沒有特別的用途，是供後續使用該prim的人知道與其有關的prim具體是哪些，因此通常不大常出現，尤其在簡單的、不涉及腳本的專案中。

[**Create a Relationship \- Omniverse Developer Guide**](https://docs.omniverse.nvidia.com/dev-guide/latest/programmer_ref/usd/properties/create-relationship.html){:target="_blank"} 
[_Universal Scene Description \(OpenUSD\) code samples for creating a Relationship\._ docs\.omniverse\.nvidia\.com](https://docs.omniverse.nvidia.com/dev-guide/latest/programmer_ref/usd/properties/create-relationship.html){:target="_blank"}

[**Universal Scene Description: UsdRelationship Class Reference**](https://openusd.org/release/api/class_usd_relationship.html){:target="_blank"} 
[_A UsdRelationship creates dependencies between scenegraph objects by allowing a prim to target other prims, attributes…_ openusd\.org](https://openusd.org/release/api/class_usd_relationship.html){:target="_blank"}
#### Metadata

Prim中除了儲存Property外，還可以儲存Metadata，顧名思義，它是data的data，像是做出這筆資料的作者名稱、針對這筆資料的註釋，也就是補充說明這個prim的data，乍聽之下，形式上與attribute差不多，可能覺得這與attribute的功能類似，但是metadata與attribute不同，因為metadata不需要resolve、interpolate，換言之，metadata大多不會更動，但是可以被覆蓋。

[**Universal Scene Description: Object Model and How the Classes Work Together**](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"} 
[_An SdfLayer provides the interface to a persistent \(in a file\) or in\-memory only \(via “anonymous” layers\) container of…_ openusd\.org](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"}

另一個不同的地方在於，metadata不能隨便客製化取名，因為他是 _strongly typed_ ，換言之，只有註冊過的保留字可以用。

[**Universal Scene Description: Object Model and How the Classes Work Together**](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"} 
[_An SdfLayer provides the interface to a persistent \(in a file\) or in\-memory only \(via “anonymous” layers\) container of…_ openusd\.org](https://openusd.org/release/api/_usd__page__object_model.html#Usd_OM_Metadata){:target="_blank"}

舉個一般的例子來說，comment就屬於metadata，開啟 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 後執行腳本，我們在 `"Box"` 中添加一些描述
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")

if box_prim:
  box_prim.SetMetadata('comment', "A prim of Cube")
  print(box_prim.GetMetadata('comment'))
```

儲存後查看\.usda可以發現prim名稱後多了括胡，其中的資料就屬於metadata。
```python
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            "A prim of Cube"
        )
        {
        }
    }
}
```

當然，metadata不只有這種，接下來將介紹其他兩種metadata
### Learn OpenUSD: Understanding Model Kinds

課程介紹了一種相對常用的metadata，kind，其分為group, assembly, and component，說白了就是讓人自己去定義每個prim的層級，kind就是prim在hierarchy中的Categories。

舉例來說，家具是component，基本上已經是基本單位了，不能再分割，當然還是有subcomponent可以用，數個家具可以group起來，整個建築物則是assembly。

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-22+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-22+V1){:target="_blank"}

一種直白的解釋就是每個prim都有個tag，叫做kind，可以填的值就是group, assembly, component and subcomponent四種，但是甚麼樣的prim屬於哪一種基本上可以自己決定，換言之，這需要跟團隊溝通，同步好大家的共識，否則這個kind沒什麼實質效益。

換言之，每個prim的kind完全屬於自定義，甚至可以不定義，因為這個kind沒有標準答案，只需要團隊有共識即可。


![](/assets/a7fa6a26a49a/1*VxEiWi94C6kSr9k3zx5U2Q.png)


在Omniverse的Property中可以找到prim的Kind\(雖然它並非Property\)，總共有四個選項可以選擇，我們可以再次使用 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 來舉例，將 `"Box"` 設定成group後儲存
```python
#usda 1.0

#...

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            kind = "group"
        )
        {
        }
    }
}
```

那如果我們想要腳本做到呢？假設我們想把kind換成subcomponent
```css
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
 box_prim.SetMetadata('kind', "subcomponent")
 print(box_prim.GetMetadata('kind'))
```

儲存後就可以查看\.usda
```python

def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            kind = "subcomponent"
        )
        {
        }
    }
}
```

只是這邊要注意 `SetMetadata()` 中第一個參數，也就是metadata的名稱如果隨意取名會跳出錯誤\(Unregistered metadata key\)，這是因為如前面所述metadata的種類是事先設計好的，不能隨便增加種類。

但我們沒有必要使用到所有的metadata，本篇最後在介紹一種metadata，active。
### Learn OpenUSD: Traversing Stages

本篇教學中會示範如何用腳本遍歷整個stage中所有的prim，但是在過程中會介紹到active這個metadata，它會影響遍歷stage時是否會考慮該Prim。

[**Course Detail \| NVIDIA**](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-21+V1){:target="_blank"} 
[_About Course Objectives Topics Covered Course Outline Stay Informed Contact Us_ learn\.nvidia\.com](https://learn.nvidia.com/courses/course-detail?course_id=course-v1:DLI+S-OV-21+V1){:target="_blank"}

一樣打開 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 後執行腳本
```python
from pxr import Usd, UsdGeom, Sdf

stage = omni.usd.get_context().get_stage()
for prim in stage.Traverse():
 print(prim.GetPath().pathString)
```

腳本很簡單的用一個for loop去遍歷所有的prim，我們預期的輸出是 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 中的三個prim，但是實際輸出如下
```bash
/Geometry
/Geometry/GroupTransform
/Geometry/GroupTransform/Box
/OmniverseKit_Persp
/OmniverseKit_Front
/OmniverseKit_Top
/OmniverseKit_Right
/OmniKit_Viewport_LightRig
/OmniKit_Viewport_LightRig/Lights
/OmniKit_Viewport_LightRig/Lights/DomeLight
/OmniKit_Viewport_LightRig/Lights/DistantLight
/Render
/Render/OmniverseKit
/Render/OmniverseKit/HydraTextures
/Render/OmniverseKit/HydraTextures/omni_kit_widget_viewport_ViewportTexture_0
/Render/Vars
/Render/Vars/LdrColor
```

可以發現只有開頭三個是屬於 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 這個layer的，至於其他的prim都是Omniverse內建的，你甚至在Stage都看不到，實際上這些東西沒有存在我們自己的layer中，而是比較像是Omniverse有自己預設的layer，這個layer是存在於App內部的。

同時，這也帶來一個麻煩，我們不能很直觀的知道到底stage中有甚麼東西，我們的\.usda不能完全代表目前的stage，這也就是Omniverse與跟單純的OpenUSD最大的差別，也證明Omniverse是一個基於OpenUSD，但同時具備額外架構的平台。

此時，若你只想找特定schema的prim，例如Scope以及Cube可以執行腳本
```python
from pxr import Usd, UsdGeom, Sdf

stage = omni.usd.get_context().get_stage()
for prim in stage.Traverse():
 if UsdGeom.Scope(prim):
  print(prim.GetPath().pathString)
 elif prim.IsA(UsdGeom.Cube):
  print(prim.GetPath().pathString)
```

如此就只會輸出
```rust
/Geometry
/Geometry/GroupTransform/Box
```
#### Active/Inactive

接著就是active這個metadata了，一樣打開 [MyModel\.usda](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-03-openusd-be14a4a5704f#a41d){:target="_blank"} 後執行以下腳本
```python
from pxr import Usd, UsdGeom, Sdf

stage: Usd.Stage = omni.usd.get_context().get_stage()
box_prim = stage.GetPrimAtPath("/Geometry/GroupTransform/Box")
if box_prim:
  box_prim.SetMetadata('active', False)
```

儲存後檢視可以發現 `"Box"` 的metadata多了一個active
```ruby
def Scope "Geometry"
{
    def Xform "GroupTransform"
    {
        def Cube "Box" (
            active = false
        )
        {
        }
    }
}
```

同時，Omniverse中Stage的 `"Box"` 也有發生變化，可以發現多了禁止的符號


![](/assets/a7fa6a26a49a/1*LURU9tKGfdbZOQq31dt5og.png)


此時重新執行Traverse的腳本可以發現輸出只剩下
```rust
/Geometry
```

除此之外當然還有其他的metadata，但這邊就不一一列舉，就自己多多嘗試或是用GPT搜尋例如：
1. `hidden` ：這個元數據鍵用於標記一個原始物體是否隱藏。相當於調用 `UsdPrim::SetHidden()` 方法。
2. `kind` ：這個元數據鍵用於指定原始物體的類型（例如，組、組件等）。
3. `assetInfo` ：這是一個字典，用於存儲與資產相關的信息，如資產的名稱、版本等。
4. `documentation` ：這個元數據鍵用於存儲與原始物體相關的文檔或描述信息。
5. `comment` ：這個元數據鍵用於存儲與原始物體相關的注釋或備註。
6. `customLayerData` ：這是一個字典，用於存儲自定義的層數據。
7. `instanceable` ：這個元數據鍵用於標記一個原始物體是否可實例化。


總之，就如同kind中的舉例，metadata就像是prim的tag
### 結論

總而言之，本篇主要介紹了prim中的data，其分為Property and Metadata，這樣我們基本上對於prim的組成有了大致的認識，除此之外也順便介紹了如何在Omniverse中執行簡單的腳本，同時可以對照畫面以及\.usd的變化，基本上就可以更深入的往下探索了。

例如被我跳過去的 **Value resolution** ，它是有關於attr解析時的策略，因為att的value來自於三個sources
- Value clips
- Authored timeSamples
- Default value


簡單來說，前兩者都跟動畫系統有關，因為相對於metadata，attr的特色就是會隨著時間內插，最後一個就是att本身儲存的預設值，優先序由上到下，如果沒有動畫的話，那大多數都是採用Default value。

值得注意的是，不同layers但是同名的attribute最終會由最強的那個opinion的attribute勝出，此時stage上compose出來的prim的attribute的value就是Default value，換言之，本篇乃至於之前的文章中stage中的attr的value都是Default value。

詳細的東西就留待下一篇介紹。

感謝你的閱讀，如果你對我的文章對你有所幫助或是意見歡迎回覆，如果你想要支持我可以：
- 拍個手👋，或是分享一些想法💬
- [追蹤我的頁面](https://medium.com/@maochinn){:target="_blank"}
- [訂閱我的專欄](https://medium.com/maochinn){:target="_blank"}
- [透過LinkedIn聯繫我](https://www.linkedin.com/in/chih-wei-chang-6526801b2/){:target="_blank"}


或是觀看我其他系列文章
- [【Omniverse】學習筆記 — 00：Kit\-based Development](../a54ae65f22bf/)
- [【Omniverse】學習筆記 — 01：Application and Extension](../e765192086c8/)
- [【Omniverse】學習筆記 — 02：Kit Workshop SIGGRAPH 2022](../2183284ed751/)
- [【Omniverse】學習筆記 — 03：OpenUSD](../be14a4a5704f/)
- [【Omniverse】學習筆記 — 04：Prims and Schemas](../8a5581d9ef78/)



_[Post](https://medium.com/maochinn/omniverse-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-05-property-and-metadata-a7fa6a26a49a){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
