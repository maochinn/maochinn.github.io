<!doctype html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Paper: Distributed Ray Tracing" /><meta name="author" content="帽捲" /><meta property="og:locale" content="en" /><meta name="description" content="分布式光線追蹤，或者我們說隨機分布式光線追蹤(Stocastically Distribute Ray Tracing)，他是在Ray Casting、Ray Tracing之後提出的改良。" /><meta property="og:description" content="分布式光線追蹤，或者我們說隨機分布式光線追蹤(Stocastically Distribute Ray Tracing)，他是在Ray Casting、Ray Tracing之後提出的改良。" /><link rel="canonical" href="https://medium-to-jekyll-starter.zhgchg.li//posts/d352576ec72a/" /><meta property="og:url" content="https://medium-to-jekyll-starter.zhgchg.li//posts/d352576ec72a/" /><meta property="og:site_name" content="Medium To Jekyll Starter" /><meta property="og:image" content="https://medium-to-jekyll-starter.zhgchg.li//assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-04-15T01:18:53+08:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://medium-to-jekyll-starter.zhgchg.li//assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" /><meta property="twitter:title" content="Paper: Distributed Ray Tracing" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@帽捲" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"帽捲"},"dateModified":"2021-01-14T12:57:54+08:00","datePublished":"2020-04-15T01:18:53+08:00","description":"分布式光線追蹤，或者我們說隨機分布式光線追蹤(Stocastically Distribute Ray Tracing)，他是在Ray Casting、Ray Tracing之後提出的改良。","headline":"Paper: Distributed Ray Tracing","image":"https://medium-to-jekyll-starter.zhgchg.li//assets/d352576ec72a/0*iuglgFW3QRS5Xsgz","mainEntityOfPage":{"@type":"WebPage","@id":"https://medium-to-jekyll-starter.zhgchg.li//posts/d352576ec72a/"},"url":"https://medium-to-jekyll-starter.zhgchg.li//posts/d352576ec72a/"}</script><title>Paper: Distributed Ray Tracing | Medium To Jekyll Starter</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Medium To Jekyll Starter"><meta name="application-name" content="Medium To Jekyll Starter"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=true" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/avatar.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Medium To Jekyll Starter</a><p class="site-subtitle fst-italic mb-0">A text-focused Jekyll theme</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/github_username" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" class="flex-shrink-0" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Paper: Distributed Ray Tracing</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link" aria-label="Sidebar"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link" aria-label="Search"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>Paper: Distributed Ray Tracing</h1><p class="post-desc fw-light mb-4">分布式光線追蹤，或者我們說隨機分布式光線追蹤(Stocastically Distribute Ray Tracing)，他是在Ray Casting、Ray Tracing之後提出的改良。</p><div class="post-meta text-muted"> <span> Posted <time data-ts="1586884733" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Apr 15, 2020 </time> </span> <span> Updated <time data-ts="1610600274" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jan 14, 2021 </time> </span><div class="mt-3 mb-3"> <a href="/assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" class="popup img-link preview-img shimmer"><img src="/assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5213 words" > <em>28 min</em> read</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Paper: Distributed Ray Tracing</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">Paper: Distributed Ray Tracing</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h3 id="paper-distributed-ray-tracing"><span class="me-2">Paper: Distributed Ray Tracing</span><a href="#paper-distributed-ray-tracing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>分布式光線追蹤，或者我們說隨機分布式光線追蹤(Stocastically Distribute Ray Tracing)，他是在Ray Casting、Ray Tracing之後提出的改良。</p><p>首先，我們可以先看看傳統Ray tracing有甚麼問題，傳統上每個pixel就用一條ray去遞迴找值，那結果其實會產生很明顯的鋸齒狀(aliasing的一種)，所以第一個問題就是反鋸齒(Anti-aliasing)。</p><p>Presentation Video</p><p><a href="https://www.youtube.com/watch?v=zCl9uSRY5Pw" target="_blank" class="img-link shimmer" ><img src="/assets/d352576ec72a/8254_hqdefault.jpg" alt="Paper Presentation :Distributed Ray Tracing" title="Paper Presentation :Distributed Ray Tracing" loading="lazy"></a></p><h4 id="anti-aliasing"><span class="me-2">Anti-aliasing</span><a href="#anti-aliasing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在講ray tracing以前，我們不妨先回到OpenGL的成像方式，我們如果要渲染一張有texture的圖我們就遇到這個問題:</p><p><a href="/assets/d352576ec72a/0*zEKRVRba70ltEa4H" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*zEKRVRba70ltEa4H" alt="Figure 1(a) OpenGL rendering" loading="lazy"></a></p><p>Figure 1(a) OpenGL rendering</p><p>可以發現後面的texture都亂掉了，那解法通常就是mipmap，也就等同於是在不同距離的texture我們用了不同的filter，也就是不同的採樣(sample)方式，由此來看，sample是相當重要的。</p><p>那回到傳統的Ray Tracing</p><p><a href="/assets/d352576ec72a/0*LGguvMiqusg7fIbh" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*LGguvMiqusg7fIbh" alt="Figure 1(b) One sample per pixel(PBRT book 3rd Figure 7.19)" loading="lazy"></a></p><p>Figure 1(b) One sample per pixel(PBRT book 3rd Figure 7.19)</p><p>其實也有類似的問題，那最明顯的問題就是鋸齒狀，那為甚麼會產生鋸齒呢?因為我們每個pixel只使用一條ray，那實際上我們從pixel打出去的並不是光線，而是有體積的光束，也就是說，我們每個pixel所表示的應該是一個面積裡的顏色，但我們只用一條ray的話，我們只能武斷的決定他是0或是1。</p><p>那最顯而易見的做法就是多打幾條:</p><p><a href="/assets/d352576ec72a/0*kymBrhuOH27vJ2pt" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*kymBrhuOH27vJ2pt" alt="Figure 1(c) 256 sample per pixel" loading="lazy"></a></p><p>Figure 1(c) 256 sample per pixel</p><p>非常明顯的，鋸齒沒有這麼明顯，因為每個pixel有了0~255階的範圍，所以在邊界的地方有了相對平滑的明度變化，因此原則上，只要我們能夠在一個pixel內打出無限條ray，那就可以無限精準。但這個方法也有個顯而易見的缺點，就是太沒有效率，原因是因為我們採用regular的方式打出多條ray，這個就是產生鋸齒的原因，只要是regular就會產生鋸齒，舉個例子來說，就是pixel，由於每張圖都是由regular排列的二維陣列，所以原則上只要是pixel-based的東西就會產生鋸齒，反過來說，鋸齒的原因就是regular的排列。</p><p>於是，就有了後面的做法，讓我們增加一些隨機性:</p><p><a href="/assets/d352576ec72a/0*o_slHGJqVVvG7_v0" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*o_slHGJqVVvG7_v0" alt="Figure 1(d) One jittering sample per pixel" loading="lazy"></a></p><p>Figure 1(d) One jittering sample per pixel</p><p>原本最naive的做法是在每個pixel的中心(或是某個固定位置)打出ray，由於是固定(regular)位置，所以會產生鋸齒。現在我們則是在一個pixel的範圍內，隨機找一個點打出ray，也就是這邊稱為jittering(抖動)，從上圖可以看到鋸齒的痕跡變得不是這麼明顯，儘管每個pixel只有打一條ray，但相對來說，也產生了很多的noise。</p><p>那如果我們多打幾條呢?</p><p><a href="/assets/d352576ec72a/0*eVKE1j4qpdpgwQtt" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*eVKE1j4qpdpgwQtt" alt="Figure 1(e) Four jittering sample per pixel" loading="lazy"></a></p><p>Figure 1(e) Four jittering sample per pixel</p><p>我們僅僅使用4條ray，就可以做出不錯的結果，雖然相對於regular的打出256條是較差的，但是一定程度上，這是權衡之下的結果，也就是較有效率的方式。</p><p>那麼，為甚麼會這樣呢，我們可以用一些影像處理的例子來說明:</p><p><a href="/assets/d352576ec72a/0*VW08mjHdvSqudCnJ" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*VW08mjHdvSqudCnJ" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*vhCCI0iUkpRMUSp4" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*vhCCI0iUkpRMUSp4" alt="Figure 2 Two binary image, Regular pattern(a), Jittered pattern(b)" loading="lazy"></a></p><p>Figure 2 Two binary image, Regular pattern(a), Jittered pattern(b)</p><p>上圖都是binary的圖片，也就是每個pixel只有黑與白，那麼為甚麼我們感受得出明暗變化也就是灰階呢?因為我們的眼睛自帶有filter，也就是會把一個區域的東西整合在一起顯示，所以我們可以利用黑白點的不同密度來展現明暗。很明顯的，左圖有非常不自然的鋸齒，而右圖沒有，這就是因為左圖使用了regular的pattern來給不同明暗的區域密度，而右圖則是使用隨機抖動的方式產生。</p><p>回到我們的Distributed Ray Tracing，我們可以做個小結，我們利用加入隨機性的抖動來更有效的sample(Jittered sampling)，他雖然不精準會產生noise，但是原則上是相對有效率的做法。另外，這種作法其實說到底就是刻意增加noise，從訊號處理的角度來看，增加noise就是降低高頻訊號，而鋸齒則剛好也是高頻訊號，所以從這個角度也可以說明為甚麼可以去除鋸齒。</p><p><a href="/assets/d352576ec72a/0*30cCoix6rvXX03ru" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*30cCoix6rvXX03ru" alt="Figure 3" loading="lazy"></a></p><p>Figure 3</p><p>另外，如果從蒙地卡羅法來思考，這樣子的方式就是non-regular Stratified sampling，也就是所謂的分層式抽樣，值得一提的是，如果使用分層式抽樣，那麼這樣子的抽樣會與維度相關，而會一定程度上失去蒙地卡羅的優點，也就是與維度無關，幸好的事，原則上我們最多就在二維上分層，所以可以當作常數看待。</p><p>看完了上面的反鋸齒，原則上這篇論文的核心概念也就清楚了，就是透過這種隨機分布的ray來有效率的sample出不同的效果。</p><h4 id="shading-model"><span class="me-2">Shading model</span><a href="#shading-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>那在我們討論shading的各種效果以前，我們先來了解一下paper所提到的shading model。</p><p><a href="/assets/d352576ec72a/0*0OEk6SnU7vqdy42Y" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*0OEk6SnU7vqdy42Y" alt="The intensity I of the reflected light at a point on a surface is an integral over the hemisphere above the surface. L is illumination function, R is reflection function" loading="lazy"></a></p><p>The intensity I of the reflected light at a point on a surface is an integral over the hemisphere above the surface. L is illumination function, R is reflection function</p><p>其實這邊所提出的model也只是概念上的model，這邊就簡單講解一下，我們ray tracing的目標就是我們從某個角度打到某個區域，並取出那個區域的顏色，而這邊的顏色就是Intensity，也就是I函數，而這個I函數則depend on光進入的反射角，也就是Intensity的數值只跟光的反射角有關。</p><p>我們來看看裡面的積分式，L表示illumination function，也就是來自某個方向的入射光的函數，所以她指相關於入射角，R則是reflect function，就是反射光的函數，整個積分式是對於所有入射光來積分。這邊舉個例子來說明，假設是一個鏡面的材質，且只有一個光束，那此時L則會變成delta function，也就是只有那條光的方向有值，其餘方向都會是0，由於是鏡面，所以也只有在對應的反射角會有光，所以R也會是delta function，那整個積分式就會退化成只有一項有值，也就是入射光對應的反射光的角度Intensity才會有值。</p><p>進一步來說，R都是使用者依據自己對於不同材質的理解去定義的。</p><p>接下來我就來談談一些shading的效果吧</p><h4 id="gloss"><span class="me-2">Gloss</span><a href="#gloss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一個典型的例子就是鏡子或者是金屬，也就是非常光滑的表面，會有很明顯的入射角反射角的關係，另一方面也可以想像成Phong Shading的specular，也就是說是view-dependent的。</p><p>下面就借用 <a href="https://web.cs.wpi.edu/~matt/courses/cs563/talks/dist_ray/dist.html" target="_blank">[1]</a> 的例子來介紹。</p><p><a href="/assets/d352576ec72a/0*t4UEhkFOHcbi8f03.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*t4UEhkFOHcbi8f03.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*vke5c-X4y7AHSeAe.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*vke5c-X4y7AHSeAe.gif" alt="Figure 3(a) This example shows a perfect reflection produced by a traditional (non-distributed) ray tracer. Notice that the edges of the reflection are very sharp." loading="lazy"></a></p><p>Figure 3(a) This example shows a perfect reflection produced by a traditional (non-distributed) ray tracer. Notice that the edges of the reflection are very sharp.</p><p><a href="/assets/d352576ec72a/0*XeAtFf4Evmfe7jmf.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*XeAtFf4Evmfe7jmf.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*7W2OcZ1SPMvseXB8.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*7W2OcZ1SPMvseXB8.gif" alt="Figure 3(b) This example shows a glossy reflection generated by distributed ray tracing. The reflection was generated by distributing 10 rays." loading="lazy"></a></p><p>Figure 3(b) This example shows a glossy reflection generated by distributed ray tracing. The reflection was generated by distributing 10 rays.</p><p>可以很明顯的看到，使用傳統方法可以產生鏡面反射的效果，那相對來說，鋸齒的狀況又再度發生了，也就是我們對於鏡面反射的sample效率不好，另一方面，我們也知道大多數的材質並不會如此光滑，所以為了改善這個情況，我們使用相同的策略，利用隨機分布式的ray來sampling。</p><p><a href="/assets/d352576ec72a/0*kjT80Q7EaW7wHDeA" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*kjT80Q7EaW7wHDeA" alt="Figure 4 Gloss can be calculated by distributing these secondary rays about the mirror direction" loading="lazy"></a></p><p>Figure 4 Gloss can be calculated by distributing these secondary rays about the mirror direction</p><p>我們在鏡面反射角的一定範圍內對反射角度做隨機的抖動，這樣就可以一定程度上消除明顯的鋸齒現象，因為我們更加有效率的對環境sampling。進一步來說，這個其實就是我們自己定義的R function，也就是我們依據對於材質的理解去調整R function在那些角度的值是多少。如果是完美鏡射的話，那這個bounding就是只有一個角度，也就是R function就變為delta function。</p><h4 id="translucency"><span class="me-2">Translucency</span><a href="#translucency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>最典型的例子就是玻璃，顯而易見的，我們也可以想到玻璃並不會都是這麼透光的，大多數都會是有一些霧面的。</p><p><a href="/assets/d352576ec72a/0*EytQjFMMb0bfPkjF.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*EytQjFMMb0bfPkjF.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*YE-RQrRfdYwFrqJw.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*YE-RQrRfdYwFrqJw.gif" alt="Figure 5(a) This example shows a perfectly translucent surface produced by a traditional (non-distributed) ray tracer. Notice that the edges of the sphere visible through the translucent pane are very sharp." loading="lazy"></a></p><p>Figure 5(a) This example shows a perfectly translucent surface produced by a traditional (non-distributed) ray tracer. Notice that the edges of the sphere visible through the translucent pane are very sharp.</p><p><a href="/assets/d352576ec72a/0*05vIhy1w3-8Fi893.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*05vIhy1w3-8Fi893.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*K09HNh1VShvp0rNa.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*K09HNh1VShvp0rNa.gif" alt="Figure 5(b) This example shows a fuzzy translucent surface generated by distributed ray tracing. The surface was generated by distributing 10 rays." loading="lazy"></a></p><p>Figure 5(b) This example shows a fuzzy translucent surface generated by distributed ray tracing. The surface was generated by distributing 10 rays.</p><p>那麼這邊的邏輯就跟在gloss一樣了，只是我們會需要額外定義一個類似R function的函數來進行折射。</p><p><a href="/assets/d352576ec72a/0*_8ctXD8cQwF92rWu" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*_8ctXD8cQwF92rWu" alt="Figure 6 Translucency is calculated by distributing the secondary rays about the main direction of the transmitted light" loading="lazy"></a></p><p>Figure 6 Translucency is calculated by distributing the secondary rays about the main direction of the transmitted light</p><h4 id="penumbrassoft-shadow"><span class="me-2">Penumbras(Soft shadow)</span><a href="#penumbrassoft-shadow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>陰影我們可以想像就是光沒照到的部分，那依據經驗，我們也知道陰影不會都是銳利的，更多的情況都是邊緣是帶有漸層的。</p><p>在傳統OpenGL的渲染中如果要做出shadow的話，最常見的做法就是shadow map，而在ray tracing中如果要形成影子，常見的方法就是shadow ray，簡單來說，就是檢查這個被sample到的點有沒有被光源照到，也就是從這個sample點朝著所有光源發射ray，如果有被其他東西擋住，那就算shadow，反之，如果沒有被東西擋住，就會把光的能量加上去，這就是shadow ray。</p><p><a href="/assets/d352576ec72a/0*KXOA-7x3HbaxZZF5.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*KXOA-7x3HbaxZZF5.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*658eB4ZBLKVh4YaI.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*658eB4ZBLKVh4YaI.gif" alt="Figure 7(a) This example shows a hard shadow produced by a traditional (non-distributed) ray tracer. Notice the discrete boundary between points that are in shadow and points that are not." loading="lazy"></a></p><p>Figure 7(a) This example shows a hard shadow produced by a traditional (non-distributed) ray tracer. Notice the discrete boundary between points that are in shadow and points that are not.</p><p><a href="/assets/d352576ec72a/0*851134bVOVHIS03V.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*851134bVOVHIS03V.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*85ANGNTAURnw0jos.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*85ANGNTAURnw0jos.gif" alt="Figure 7(b) This example shows a technique for generating soft shadows that is not based on distributed ray tracing. This technique is based on uniformly sampling an area light source. Although the penumbra and umbra of the shadow are clearly visible, the variation between them is rigid." loading="lazy"></a></p><p>Figure 7(b) This example shows a technique for generating soft shadows that is not based on distributed ray tracing. This technique is based on uniformly sampling an area light source. Although the penumbra and umbra of the shadow are clearly visible, the variation between them is rigid.</p><p><a href="/assets/d352576ec72a/0*uvSount_rl2cyGKl.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*uvSount_rl2cyGKl.gif" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*t1UsVETpzba9qOIO.gif" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*t1UsVETpzba9qOIO.gif" alt="Figure 7(c) This example shows a soft shadow generated by distributed ray tracing. The light source was sampled using 10 rays." loading="lazy"></a></p><p>Figure 7(c) This example shows a soft shadow generated by distributed ray tracing. The light source was sampled using 10 rays.</p><p>Fig 7(a)是使用點光源的情況下，因為光源只是在3D空間是一個點，所以有無照到光就會變成0和1而已，但在一般情況下的光源都是所謂的area light，也就是光源不只是一個點，是一個面積甚至是體積，反過來說，我們之所以可以使用point light是因為我們假射光源離物體很遠，所以這樣子的簡化是合理的。</p><p>所以如果想要做出軟陰影的效果，我們必須把光源變成area light，Fig 7(b)則是每個sample點對area light的四個角發射shadow ray，可以發現更接近現實，但是這就是低效率的sample，Fig 7(c)則是使用了隨機分布式的shadow ray。</p><p><a href="/assets/d352576ec72a/0*XGSlkProrqdtdgJQ" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*XGSlkProrqdtdgJQ" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*8vp-MX6jLujIL-iq" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*8vp-MX6jLujIL-iq" alt="Figure 8(a) (b) The distribution of the shadow rays must be weighted according the projected area and brightness of different parts of the light source" loading="lazy"></a></p><p>Figure 8(a) (b) The distribution of the shadow rays must be weighted according the projected area and brightness of different parts of the light source</p><p>這邊值得一提的是，如果不用shadow ray能不能產生shadow ray呢?答案是能，只要你正常的用reflect ray去sample整個場景，如果撞到area light，那就給他加上光的能量，那這樣一能做到shadow的效果，但進一步來說，一條ray能剛好打到light的機率實在是很低，如果你的光源又是很小的話，所以shadow ray並不是一定要用，他是對於產生shadow效果的一種hack。但有一說一，如果使用shadow ray，就無法產生Caustics效果，因為你因為hack，所以直接將後續的tracing中止掉。</p><p>這邊做個小結，對於各種材質我們都可以使用隨機分部式來達成各種效果，反過來說，我們是因為對於某個材質的理解，才設計不同的R function來試圖做出某種效果，所以這並不意味著一定需要設計一個大的bounding來做所有的材質，但是核心的概念上，我們會需要用 <strong>隨機</strong> 的概念，因為這可以有效率的sample。</p><p>舉例來說，如果我們要產生沒這麼光滑的平面不一定需要隨機，我們可以只是定義一個bounding，然後regular或是固定pattern的方式做反射，這麼做仍然可以產生所謂Gloss的效果，只是還是會有鋸齒的產生，所以這篇論文的核心是在於 <strong>隨機。</strong></p><h4 id="depth-of-field"><span class="me-2">Depth of Field</span><a href="#depth-of-field" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>除了上述那些屬於shading範圍的效果，還有一種效果叫做景深(Depth of Field)，這個效果是來自於相機的鏡頭產生的，更準確來說，是因為凸透鏡造成的。我們一樣可以回想OpenGL的render model，大多數的camera model就是來自於針孔相機。</p><p><a href="/assets/d352576ec72a/0*lqB6bwdnBrd9xIGT" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*lqB6bwdnBrd9xIGT" alt="Figure 9 pinhole camera model" loading="lazy"></a></p><p>Figure 9 pinhole camera model</p><p>對於針孔相機，每個光源(或者說有照到光的面積)都會1對1的照在成像平面上，這就可以確保成像平面的清晰，而現實中的成像平面所做出來的事倒立實像，但在OpenGL的camera，我們會定義一個near clip plane，在概念上，他就是虛擬成像平面，而針孔的位置就是像機的位置，為甚麼可以這樣設定就是因為針孔相機的定義，1對1，所以無論是在什麼位置差一個平面他們的內容都與成像平面相同，只是大小、正倒立有差別而已，所以我們用的camera model就直接這樣子來簡化了。</p><p><a href="/assets/d352576ec72a/0*swa7sqqOsUUcNEzT.png" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*swa7sqqOsUUcNEzT.png" alt="Figure 10 OpenGL camera model" loading="lazy"></a></p><p>Figure 10 OpenGL camera model</p><p>但在現實生活中，針孔相機不像電腦中，只要sample到就可以不損耗的把能量打在pixel，針孔相機的曝光往往不足，也就是非常暗，所以後來就使用凸透鏡來取代針孔，讓成像平面上的點更亮，但這相對遇到了另個問題，circle of confusion。</p><p><a href="/assets/d352576ec72a/0*Eg4YxLgGhg7eg95g" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*Eg4YxLgGhg7eg95g" alt="Figure 11 Circle of Confusion" loading="lazy"></a></p><p>Figure 11 Circle of Confusion</p><p>因為凸透鏡說到底就是讓多個點都打在一個點，也就是多對1，那此時偌多的那邊如果資訊不同，那被對應到的這個1就會是各種混合，也就是會模糊，所以這就會有所謂的focal point的問題，這邊注意，focal point跟focus point是不同東西。也就是說如果東西不在focal point上，那個東西在成像平面上就會有模糊，幸運的是，focal point的距離是固定的，也就是說在focal point都會在一個平面上，也就是focal plane，那麼在這個focal plane上與成像平面就又會是1對1的，也就是在focal plane上的東西都能夠清晰成像。</p><p><a href="/assets/d352576ec72a/0*8f4UNhWcO5zSKK6C" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*8f4UNhWcO5zSKK6C" alt="Figure 12" loading="lazy"></a></p><p>Figure 12</p><p>只要定義了circle of confusion的大小，也就是我們自己認為模糊到神麼程度是可以接受的，那我們也就可以反推focal plane前後多少距離是我們可以接受的，而這個距離就會是depth of field。</p><p>那為了產生這樣子的效果，我們就必須把camera model成透鏡相機，而這在實作中，我們仍然可以用類似OpenGL的做法，也就是我們把透鏡位置當作相機位置，但此時我們不能隨便用near clip plane，因為這個plane必須要跟成像平面1對1，那麼此時我們就拿focal plane來當作虛擬成像平面。但因為我們不能在透鏡上做無限的sample，所以我們為了有效率的sample，我們仍採用相同的策略，也就是隨機分布式的ray。</p><p><a href="/assets/d352576ec72a/0*6nOS5bJFlxmbCEfX" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*6nOS5bJFlxmbCEfX" alt="Figure 13 Depth of field occurs because the lens is a finite size. Each point on the lens “looks” at the same point on the focal plane." loading="lazy"></a></p><p>Figure 13 Depth of field occurs because the lens is a finite size. Each point on the lens “looks” at the same point on the focal plane.</p><p>其實，針孔相機可以視為透鏡相機的特例，也就是只使用透鏡中心位置的透鏡相機，另外，透鏡相機除了可以產生景深這種效果，其實還可以讓sample到更多物體，因為他的ray可能可以剛好繞過擋在前面的物體，但如果是針孔相機，那就只能sample到最近的那個點了。</p><p><a href="/assets/d352576ec72a/0*NvvGlObtIkgTnkku" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*NvvGlObtIkgTnkku" alt="Figure 14 The view of the environment is different from different parts of the lens" loading="lazy"></a></p><p>Figure 14 The view of the environment is different from different parts of the lens</p><h4 id="motion-blur"><span class="me-2">Motion Blur</span><a href="#motion-blur" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>這個效果也是來自於現實相機，原因就是曝光時間過長，所以成像平面上的一個點被多個點所照射，也就是多對1，這就會造成模糊。</p><p><a href="/assets/d352576ec72a/0*7HTJ6C_N4xQpybdT" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*7HTJ6C_N4xQpybdT" alt="" loading="lazy"></a></p><p><a href="/assets/d352576ec72a/0*8aJWFVDhtqunjKvh" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*8aJWFVDhtqunjKvh" alt="Figure 14 Motion blur" loading="lazy"></a></p><p>Figure 14 Motion blur</p><p>要做出motion blur最直觀的做法就是做一些blur就好，也就是某些區塊做不同mask的filter就好，但是困難點就是你要怎麼選取區塊，由於深度也不是簡單的幾個位數，所以要區分出所謂前後景分別做blur是相對複雜的，但利用這篇paper的架構就是相對簡單的，就是在時間上作隨機分布式ray，最後再把結果blur起來，因為理想上是我們在不同時間點上render在平均，但是這樣成本太高，所以我們用有效的sample來取代，也就是隨機分布式。</p><h4 id="result"><span class="me-2">Result</span><a href="#result" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>最後就是來看看整個流程吧，我們先選定要在哪個pixel射出ray，然後在pixel的範圍內隨機分布數個sample point，然後在時間上隨機分布，在透鏡的範圍內隨機分布，如果有與物體相交就在反射方向隨機分布，在折射方向隨機分布，在光源方向隨機分布，最後把所有sample個別平均起來就好了。</p><p><a href="/assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" class="popup img-link shimmer"><img src="/assets/d352576ec72a/0*iuglgFW3QRS5Xsgz" alt="" loading="lazy"></a></p><p>很明顯的雖然說是有效率的sample，但是究竟還是oversampling，尤其是在每個階段都要射出多個ray，這樣子的ray會是指數成長的，也就是只要遞迴的深度一多，整個算法就會很慢。所以才會有後面paper的改良，但大方向都是相同的，就是要更有效率的sample。</p><p>可以額外提一下的事，雖然論文原文並沒有提到蒙地卡羅法(Monte Carlo method)，但是後人都會為他附會上他是蒙地卡羅法，而就概念上，我們在shading model上有展示，任意點的顏色或者說是Intensity都是一個積分式，但對於這樣一個針對所有角度的積分式，並且場景複雜的情況下，這樣子的積分可以想像成無限複雜的多項式，而對於無限複雜的多項式我們可以用泰勒展開式、拉普拉斯等等方式來近似，那對於積分式，我們可以用數值分析的方法來近似，就像是最簡單的黎曼和、辛普森等方法，原則上就是固定的對多項式採樣，但這就牽涉到所謂的維度災難(curse of dimensionality)，這會造成採樣的成本大幅提高。</p><p>但蒙地卡羅法就在此時登場，他的error只與採樣數量有關，而與維度無關，而蒙地卡羅法的核心就是在一個機率分布下進行採樣，而這個機率分部則會是一個給定的隨機，所以回到整個論文，我們可以發現做的事情就是我們給定一個隨機的分布，並在這個分布之中進行採樣，而這麼做就跟蒙地卡羅法是一樣的。</p><h4 id="reference"><span class="me-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>[1] <a href="https://web.cs.wpi.edu/~matt/courses/cs563/talks/dist_ray/dist.html" target="_blank">Distributed Ray Tracing by Allen Martin</a></p><p>[2] <a href="https://artis.inrialpes.fr/Enseignement/TRSA/CookDistributed84.pdf" target="_blank">Distributed Ray Tracing</a></p><p>[3] <a href="http://www.cs.cmu.edu/afs/cs/academic/class/15462-s15/www/lec_slides/p51-cook.pdf" target="_blank">Stochastic Sampling in Computer Graphics, ROBERT L. COOK</a></p><p>[4] <a href="http://luthuli.cs.uiuc.edu/~daf/courses/ComputerGraphics/Week3/distributed-final.pdf" target="_blank">CS319 Advanced Topics in Computer Graphics, John C. Hart</a></p><p>[5] <a href="https://slideplayer.com/slide/16433295/" target="_blank">CS655</a></p><p>[6] <a href="https://slideplayer.com/slide/14504266/" target="_blank">Modeling Motion Blur in Computer - Generated Image, Dmitriy Bespalov</a></p><p>[7] <a href="https://en.wikipedia.org/wiki/Dither" target="_blank">Dither wiki</a></p><p>[8] <a href="http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html" target="_blank">PBR Book 3rd chapter 7.3</a></p><p>[9] <a href="https://kknews.cc/zh-tw/photography/3elrrx3.html" target="_blank">你沒見過的景深影響因素光學原理圖解</a></p><p>[10] <a href="http://photo.popart.hk/newweb/archives/3187" target="_blank">3分鐘搞懂光圈景深原理</a></p><p><em><a href="https://medium.com/maochinn/paper-distributed-ray-tracing-d352576ec72a" target="_blank">Post</a> converted from Medium by <a href="https://github.com/ZhgChgLi/ZMediumToMarkdown" target="_blank">ZMediumToMarkdown</a>.</em></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/maochinn/">Maochinn</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/computer-graphics/" class="post-tag no-text-decoration" >computer-graphics</a> <a href="/tags/ray-tracing/" class="post-tag no-text-decoration" >ray-tracing</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Paper:%20Distributed%20Ray%20Tracing%20-%20Medium%20To%20Jekyll%20Starter&url=https%3A%2F%2Fmedium-to-jekyll-starter.zhgchg.li%2F%2Fposts%2Fd352576ec72a%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Paper:%20Distributed%20Ray%20Tracing%20-%20Medium%20To%20Jekyll%20Starter&u=https%3A%2F%2Fmedium-to-jekyll-starter.zhgchg.li%2F%2Fposts%2Fd352576ec72a%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fmedium-to-jekyll-starter.zhgchg.li%2F%2Fposts%2Fd352576ec72a%2F&text=Paper:%20Distributed%20Ray%20Tracing%20-%20Medium%20To%20Jekyll%20Starter" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/83f3d470b656/">【自動化】學習筆記 — 01：硬體</a><li class="text-truncate lh-lg"> <a href="/posts/de28dc8582ec/">【自動化】學習筆記 — 00</a><li class="text-truncate lh-lg"> <a href="/posts/6560b300f03c/">【工作】NVIDIA GTC Taipai 2025 — Day 0：Building Digital Twins for Physical AI With NVIDIA Omniverse</a><li class="text-truncate lh-lg"> <a href="/posts/230d146467b3/">【工作】NVIDIA GTC Taipai 2025 — Day 1：Manufacturing sessions</a><li class="text-truncate lh-lg"> <a href="/posts/616f6e63db42/">【工作】NVIDIA GTC Taipai 2025 — Day 2：Physical Al and Robotics Sessions</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/computer-graphics/">computer-graphics</a> <a class="post-tag btn btn-outline-primary" href="/tags/omniverse/">omniverse</a> <a class="post-tag btn btn-outline-primary" href="/tags/digital-art/">digital-art</a> <a class="post-tag btn btn-outline-primary" href="/tags/nvidia/">nvidia</a> <a class="post-tag btn btn-outline-primary" href="/tags/blender/">blender</a> <a class="post-tag btn btn-outline-primary" href="/tags/krenz/">krenz</a> <a class="post-tag btn btn-outline-primary" href="/tags/business-trip/">business-trip</a> <a class="post-tag btn btn-outline-primary" href="/tags/siggraph/">siggraph</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E9%9B%BB%E8%85%A6%E5%9C%96%E5%AD%B8/">電腦圖學</a> <a class="post-tag btn btn-outline-primary" href="/tags/cosmos/">cosmos</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/a185240f841b/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1613993811" data-df="ll" > Feb 22, 2021 </time><h4 class="pt-0 my-2">【Pytorch3D】Motion Path Editing</h4><div class="text-muted"><p>先寫一些我要記錄的東西好了，一天到晚挖坑都不填的</p></div></div></a></article><article class="col"> <a href="/posts/b144f23b5bb5/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1593854848" data-df="ll" > Jul 4, 2020 </time><h4 class="pt-0 my-2">FLTK建置</h4><div class="text-muted"><p>FLTK算是蠻老的一個C++…</p></div></div></a></article><article class="col"> <a href="/posts/83b855e6f76b/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1584764366" data-df="ll" > Mar 21, 2020 </time><h4 class="pt-0 my-2">CG test</h4><div class="text-muted"><p>subtitle</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/a01759e95c9/" class="btn btn-outline-primary" aria-label="Older" ><p>Blender 2.82 Render Engine</p></a> <a href="/posts/72d50d13fbc/" class="btn btn-outline-primary" aria-label="Newer" ><p>【數位美術】Krenz透視一期 — 00</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://twitter.com/username">your_full_name</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.3.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.<br/> Automatically sync posts from Medium with <a href="https://zhgchg.li/posts/en-medium-to-jekyll/" target="_blank">ZhgChg.Li</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/computer-graphics/">computer-graphics</a> <a class="post-tag btn btn-outline-primary" href="/tags/omniverse/">omniverse</a> <a class="post-tag btn btn-outline-primary" href="/tags/digital-art/">digital-art</a> <a class="post-tag btn btn-outline-primary" href="/tags/nvidia/">nvidia</a> <a class="post-tag btn btn-outline-primary" href="/tags/blender/">blender</a> <a class="post-tag btn btn-outline-primary" href="/tags/krenz/">krenz</a> <a class="post-tag btn btn-outline-primary" href="/tags/business-trip/">business-trip</a> <a class="post-tag btn btn-outline-primary" href="/tags/siggraph/">siggraph</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E9%9B%BB%E8%85%A6%E5%9C%96%E5%AD%B8/">電腦圖學</a> <a class="post-tag btn btn-outline-primary" href="/tags/cosmos/">cosmos</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
